---
title: "1) hpf18_PreProcessing "
author: "Kane"
date: "August 8th, 2019"
output: html_document
editor_options: 
  chunk_output_type: console
---

Setting working directory
```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

Importing libraries
```{r echo=FALSE}
###  Clearing workspace and loading the required packages
library(scater)
library(SingleCellExperiment)
library(tidyverse)
library(org.Dr.eg.db)

```

```{r Importing dataset} 

# Importing count matrix, cluster IDs and cluster names.
count_file <- "./hpf18_count_matrix.csv" 
clustid_file <- "./hpf18_clustID.txt"
clust_names_file <- "./hpf18_clustNames.csv"

count_matrix <- read_csv(count_file) %>% column_to_rownames(var = 'Row')
clustid <- read_table(clustid_file, col_names = FALSE)
clust_names <- read_csv(clust_names_file)

```

```{r Preparing column metadata}

# Preparing column data file
hpf18_clusternames <- dplyr::filter(clust_names, `TimePoint(hpf)` == 18)

# Appending 18hpf to cell names 
colnames(count_matrix) <- paste0("18hpf_", colnames(count_matrix))
cellnames <- colnames(count_matrix)[-1]

# Extracting library names from cell names
pattern="_(.*?)_"
matches <- regmatches(cellnames,regexec(pattern,cellnames))
libnames <- sapply(matches, function(x) x[2])

# Merging all 3 dataframes and renaming columns
name_cluster_lib <- Reduce(cbind, list(cellnames, clustid, libnames))
colDataMatrix <- dplyr::left_join(name_cluster_lib, hpf18_clusternames, by = c("X1" = "ClusterID")) %>% rename(cells = init, 
                clusterID = X1,
                libraryName = `x[[i]]`,
                timepoint = `TimePoint(hpf)`,
                clusterNames = ClusterName)
```

```{r Preparing row metadata}
# Preparing row data file

ensembl <- AnnotationDbi::mapIds(org.Dr.eg.db, keys=rownames(hpf18), keytype = "SYMBOL",column = "ENSEMBL")

```

```{r SCE object QC echo=TRUE}
# Creating SCE object and obtaining Ensembl IDs

hpf18 <- SingleCellExperiment(assays = list(counts = as.matrix(count_matrix)), colData = colDataMatrix, rowData = ensembl)

stats <- perCellQCMetrics(hpf18, exprs_values = "counts", percent_top = c(50, 100, 200, 500),
detection_limit = 0)

qc <- quickPerCellQC(stats, batch = hpf18$libraryName)
colSums(as.matrix(qc))

colData(hpf18) <- cbind(colData(hpf18), stats)
unfiltered$discard <- qc$discard

gridExtra::grid.arrange(
    plotColData(unfiltered, x = "libraryName", y="sum", colour_by="discard") +
        scale_y_log10() + ggtitle("Total count"),
    plotColData(unfiltered, x = "libraryName", y="detected", colour_by="discard") +
        scale_y_log10() + ggtitle("Detected features")
)

# Retaining genes that are expressed in at least 1 cell in the dataset
ave_counts <- rowSums(assay(unfiltered, "counts")) / dim(unfiltered)[2]
to_keep <- ave_counts > 0

hpf18<- hpf18[to_keep, !qc$discard]
hpf18
```

```{r Saving RDS object}

saveRDS(hpf18, file = "./rds/hpf18_QCed_new.rds" )

```

