[
["index.html", "Chapter 1 Introduction 1.1 Objectives 1.2 Description: 1.3 Links 1.4 Created by:", " Chapter 1 Introduction This is the github repository for the “Hands-on guide to single cell RNA seq analysis in R computational workshop” series given to the AMA and Steventon labs on 4th June 2020. 1.1 Objectives The volume of online resources on the single-cell field is vast. We hope that this short practical session will help point you in the right direction in conducting your own scRNA-seq data analysis by: Highlighting the relevant reading material, scRNA-seq packages and other resources available for further study. Sharing practical advice on dealing with issues that you may encounter in your own analyses. Providing you with code as starting material to tinker with. 1.2 Description: We will be studying the scRNA-seq dataset of 18hpf zebrafish embryos, with a focus on examining the gene expression states of the tailbud Neuromesodermal progenitors. Additioanlly we will be taking a closer look at some key techniques, highlighting important details to keep in mind both when implementing and evaluating single-cell anaylsis. We hope that this will provide a good starting point for getting to grips with this fast-moving field, and encourage you to contact us for further disucssion or advice if needed. 1.3 Links Reference paper Dataset repository 1.4 Created by: Kane Toh Giles Harper-Donnelly "],
["downloading-data.html", "Chapter 2 Downloading data", " Chapter 2 Downloading data library(R.utils) library(tidyverse) urls = c(&quot;https://www.ncbi.nlm.nih.gov/geo/download/?acc=GSM3067194&amp;format=file&amp;file=GSM3067194%5F18hpf%2Ecsv%2Egz&quot;, &quot;https://www.ncbi.nlm.nih.gov/geo/download/?acc=GSM3067194&amp;format=file&amp;file=GSM3067194%5F18hpf%5FclustID%2Etxt%2Egz&quot;,&quot;https://www.ncbi.nlm.nih.gov/geo/download/?acc=GSE112294&amp;format=file&amp;file=GSE112294%5FClusterNames%2Ecsv%2Egz&quot;) destination = c(&quot;./hpf18_count_matrix.csv.gz&quot;, &quot;./hpf18_clustID.txt.gz&quot;, &quot;./hpf18_clustNames.csv.gz&quot; ) for (i in 1:length(urls)){ download.file(urls[i], destination[i], mode = &quot;wb&quot;) gunzip(destination[i]) } "],
["quality-control.html", "Chapter 3 Quality Control 3.1 Overview 3.2 Importing libraries 3.3 Importing the data 3.4 Preparing the column metadata 3.5 Preparing the row metadata 3.6 Constructing the single cell experiment object 3.7 Quality control with scater 3.8 Saving the RDS object 3.9 Session Info 3.10 Solutions", " Chapter 3 Quality Control 3.1 Overview In this section, we will construct the SingleCellExperiment object, and then perform quality control on the dataset. The workflow below, taken from chapter 5 of this text Orchestrating Single-Cell Analysis, neatly summarises the entire scRNA-seq workflow. Q1) Which steps of the workflow are we executing in this notebook? Figure 3.1: Figure 1: Schematic of a typical scRNA-seq analysis workflow. Each stage (separated by dashed lines) consists of a number of specific steps, many of which operate on and modify a SingleCellExperiment instance. 3.2 Importing libraries ### Clearing workspace and loading the required packages library(scater) #For quality control library(SingleCellExperiment) # Data structure to house out data library(tidyverse) library(org.Dr.eg.db) #Zebrafish annotation database 3.3 Importing the data Q2) What does the %&gt;% symbol do? # Importing count matrix, cluster IDs and cluster names. count_file &lt;- &quot;./hpf18_count_matrix.csv&quot; clustid_file &lt;- &quot;./hpf18_clustID.txt&quot; clust_names_file &lt;- &quot;./hpf18_clustNames.csv&quot; count_matrix &lt;- read_csv(count_file) %&gt;% column_to_rownames(var = &#39;Row&#39;) clustid &lt;- read_table(clustid_file, col_names = FALSE) clust_names &lt;- read_csv(clust_names_file, col_types = cols( &quot;TimePoint(hpf)&quot;= col_double(), &quot;ClusterID&quot; = col_double(), &quot;ClusterName&quot; = col_character())) 3.4 Preparing the column metadata In the next code chunk, we will prepare the column metadata which contains information about each cell in the dataset. We will want to append the zebrafish stage as a prefix to the cell names, in case we want to keep track of cells from different developmental stages in our downstream analyses. We will also extract the library names from the cell names using a simple regular expression that succinctly represents our search target. Lastly, we will combine the updated cell names, library names, cluster IDs and cluster names into a single dataframe, and rename the columns accordingly. To do this, we use the reduce function, which iteratively applies the function cbind (short for column bind) to a list containing our columns of interest. We also used the left_join function from the dplyr package. Join functions Q3) What does the [0-9]* syntax within the regular expression represent? Q4) Must we use left_join to achieve our goal here? # Preparing column data file hpf18_clusternames &lt;- dplyr::filter(clust_names, `TimePoint(hpf)` == 18) # Appending 18hpf to cell names colnames(count_matrix) &lt;- paste0(&quot;18hpf_&quot;, colnames(count_matrix)) cellnames &lt;- colnames(count_matrix) # Extracting library names from cell names pattern=&quot;DEW[0-9]*&quot; libnames &lt;- regmatches(cellnames,regexec(pattern,cellnames)) %&gt;% unlist() # Merging all 3 dataframes and renaming columns name_cluster_lib &lt;- Reduce(cbind, list(cellnames, clustid, libnames)) colDataMatrix &lt;- dplyr::left_join(name_cluster_lib, hpf18_clusternames, by = c(&quot;X1&quot; = &quot;ClusterID&quot;)) %&gt;% dplyr::rename(cells = init, clusterID = X1, libraryName = `x[[i]]`, timepoint = `TimePoint(hpf)`, clusterNames = ClusterName) dim(colDataMatrix) ## [1] 6962 5 3.5 Preparing the row metadata We use the AnnotationDbi package below to obtain the ensembl gene identifiers for our gene symbols. Converting Gene names. For more information about annotation packages, see Annotations # Preparing row data file #keytypes(org.Dr.eg.db) ensembl &lt;- AnnotationDbi::mapIds(org.Dr.eg.db, keys=rownames(count_matrix), keytype = &quot;SYMBOL&quot;,column = &quot;ENSEMBL&quot;) ## &#39;select()&#39; returned 1:many mapping between keys and columns tail(ensembl) ## zwilch zyg11 zymnd12 ## &quot;ENSDARG00000057100&quot; &quot;ENSDARG00000007737&quot; NA ## zyx zzef1 zzz3 ## &quot;ENSDARG00000075733&quot; &quot;ENSDARG00000094380&quot; &quot;ENSDARG00000077581&quot; 3.6 Constructing the single cell experiment object At this stage, we have the following prepared: The raw count matrix of the 18hpf zebrafish dataset The column metadata which describes information regarding each cell such as its Dropseq library name, clusterID assigned by the authors and the associated cluster name The row metadata which contains the ensembl gene names. We will parse all 3 datasets as arguments into the SingleCellExperiment() constructor. # Creating SCE object and obtaining Ensembl IDs hpf18 &lt;- SingleCellExperiment(assays = list(counts = as.matrix(count_matrix)), colData = colDataMatrix) rowData(hpf18)$ensembl &lt;- ensembl 3.7 Quality control with scater Using the scater package, we obtain useful QC metrics for the dataset and discard cells with abnormally low total number of RNA or expressed features. Q5) How does the quickPerCellQC function determine which cells are outliers? What is the median absolute deviation? stats &lt;- perCellQCMetrics(hpf18, exprs_values = &quot;counts&quot;, percent_top = c(50, 100, 200, 500), detection_limit = 0) qc &lt;- quickPerCellQC(stats, batch = hpf18$libraryName) colData(hpf18) &lt;- cbind(colData(hpf18), stats) hpf18$discard &lt;- qc$discard gridExtra::grid.arrange( plotColData(hpf18, x = &quot;libraryName&quot;, y=&quot;sum&quot;, colour_by=&quot;discard&quot;) + scale_y_log10() + ggtitle(&quot;Total count&quot;), plotColData(hpf18, x = &quot;libraryName&quot;, y=&quot;detected&quot;, colour_by=&quot;discard&quot;) + scale_y_log10() + ggtitle(&quot;Detected features&quot;) ) Figure 3.2: Figure 2: Quality control plots from the 18hpf zebrafish data, with the total RNA count and detected features as the quality metrics. Each point is a cell and colored according to whether it is identified as an outlier within each batch (library names) or not. Notice that there are only a few cells that are discarded. This is because the authors have already performed a first pass in the quality control. colSums(as.matrix(qc)) ## low_lib_size low_n_features discard ## 0 8 8 Apart from removing the outlier cells and thus reducing the dimensions of the column space, we can also reduce the number of features. We take a conservative approach here: we retain all genes that are expressed in at least 1 cell in the dataset. # Retaining genes that are expressed in at least 1 cell in the dataset ave_counts &lt;- rowSums(assay(hpf18, &quot;counts&quot;)) / dim(hpf18)[2] to_keep &lt;- ave_counts &gt; 0 sum(!to_keep) ## [1] 381 We subset our dataset with the 2 boolean conditions established above and save our results. hpf18&lt;- hpf18[to_keep, !qc$discard] hpf18 ## class: SingleCellExperiment ## dim: 30296 6954 ## metadata(0): ## assays(1): counts ## rownames(30296): LOC100000009 LOC100000024 ... zzef1 zzz3 ## rowData names(1): ensembl ## colnames(6954): 18hpf_DEW038_TGAGAAGCACT_CAACGTGG ## 18hpf_DEW038_TGAACGCTCAG_AACCCTTG ... ## 18hpf_DEW003_TGACAAGTCAT_GTTTACGT 18hpf_DEW003_TGCAAGGG_GGGAACGA ## colData names(13): cells clusterID ... total discard ## reducedDimNames(0): ## altExpNames(0): 3.8 Saving the RDS object saveRDS(hpf18, file = &quot;./rds/hpf18_QCed_new.rds&quot; ) write_csv(as_tibble(colData(hpf18)), path = &quot;./hpf18_coldata.csv&quot;) 3.9 Session Info View Session Info devtools::session_info() ## - Session info --------------------------------------------------------------- ## setting value ## version R version 4.0.0 (2020-04-24) ## os Windows 10 x64 ## system x86_64, mingw32 ## ui RTerm ## language (EN) ## collate English_United Kingdom.1252 ## ctype English_United Kingdom.1252 ## tz Asia/Kuala_Lumpur ## date 2020-06-04 ## ## - Packages ------------------------------------------------------------------- ## package * version date lib source ## AnnotationDbi * 1.50.0 2020-04-27 [1] Bioconductor ## assertthat 0.2.1 2019-03-21 [1] CRAN (R 4.0.0) ## backports 1.1.6 2020-04-05 [1] CRAN (R 4.0.0) ## beeswarm 0.2.3 2016-04-25 [1] CRAN (R 4.0.0) ## Biobase * 2.48.0 2020-04-27 [1] Bioconductor ## BiocGenerics * 0.34.0 2020-04-27 [1] Bioconductor ## BiocNeighbors 1.6.0 2020-04-27 [1] Bioconductor ## BiocParallel 1.22.0 2020-04-27 [1] Bioconductor ## BiocSingular 1.4.0 2020-04-27 [1] Bioconductor ## bit 1.1-15.2 2020-02-10 [1] CRAN (R 4.0.0) ## bit64 0.9-7 2017-05-08 [1] CRAN (R 4.0.0) ## bitops 1.0-6 2013-08-17 [1] CRAN (R 4.0.0) ## blob 1.2.1 2020-01-20 [1] CRAN (R 4.0.0) ## bookdown 0.19 2020-05-15 [1] CRAN (R 4.0.0) ## broom 0.5.6 2020-04-20 [1] CRAN (R 4.0.0) ## callr 3.4.3 2020-03-28 [1] CRAN (R 4.0.0) ## cellranger 1.1.0 2016-07-27 [1] CRAN (R 4.0.0) ## cli 2.0.2 2020-02-28 [1] CRAN (R 4.0.0) ## colorspace 1.4-1 2019-03-18 [1] CRAN (R 4.0.0) ## cowplot 1.0.0 2019-07-11 [1] CRAN (R 4.0.0) ## crayon 1.3.4 2017-09-16 [1] CRAN (R 4.0.0) ## DBI 1.1.0 2019-12-15 [1] CRAN (R 4.0.0) ## dbplyr 1.4.3 2020-04-19 [1] CRAN (R 4.0.0) ## DelayedArray * 0.14.0 2020-04-27 [1] Bioconductor ## DelayedMatrixStats 1.10.0 2020-04-27 [1] Bioconductor ## desc 1.2.0 2018-05-01 [1] CRAN (R 4.0.0) ## devtools 2.3.0 2020-04-10 [1] CRAN (R 4.0.0) ## digest 0.6.25 2020-02-23 [1] CRAN (R 4.0.0) ## dplyr * 0.8.5 2020-03-07 [1] CRAN (R 4.0.0) ## ellipsis 0.3.0 2019-09-20 [1] CRAN (R 4.0.0) ## evaluate 0.14 2019-05-28 [1] CRAN (R 4.0.0) ## fansi 0.4.1 2020-01-08 [1] CRAN (R 4.0.0) ## farver 2.0.3 2020-01-16 [1] CRAN (R 4.0.0) ## forcats * 0.5.0 2020-03-01 [1] CRAN (R 4.0.0) ## fs 1.4.1 2020-04-04 [1] CRAN (R 4.0.0) ## generics 0.0.2 2018-11-29 [1] CRAN (R 4.0.0) ## GenomeInfoDb * 1.24.0 2020-04-27 [1] Bioconductor ## GenomeInfoDbData 1.2.3 2020-05-11 [1] Bioconductor ## GenomicRanges * 1.40.0 2020-04-27 [1] Bioconductor ## ggbeeswarm 0.6.0 2017-08-07 [1] CRAN (R 4.0.0) ## ggplot2 * 3.3.0 2020-03-05 [1] CRAN (R 4.0.0) ## glue 1.4.0 2020-04-03 [1] CRAN (R 4.0.0) ## gridExtra 2.3 2017-09-09 [1] CRAN (R 4.0.0) ## gtable 0.3.0 2019-03-25 [1] CRAN (R 4.0.0) ## haven 2.2.0 2019-11-08 [1] CRAN (R 4.0.0) ## highr 0.8 2019-03-20 [1] CRAN (R 4.0.0) ## hms 0.5.3 2020-01-08 [1] CRAN (R 4.0.0) ## htmltools 0.4.0 2019-10-04 [1] CRAN (R 4.0.0) ## httr 1.4.1 2019-08-05 [1] CRAN (R 4.0.0) ## IRanges * 2.22.1 2020-04-28 [1] Bioconductor ## irlba 2.3.3 2019-02-05 [1] CRAN (R 4.0.0) ## jsonlite 1.6.1 2020-02-02 [1] CRAN (R 4.0.0) ## knitr 1.28 2020-02-06 [1] CRAN (R 4.0.0) ## lattice 0.20-41 2020-04-02 [2] CRAN (R 4.0.0) ## lifecycle 0.2.0 2020-03-06 [1] CRAN (R 4.0.0) ## lubridate 1.7.8 2020-04-06 [1] CRAN (R 4.0.0) ## magrittr 1.5 2014-11-22 [1] CRAN (R 4.0.0) ## Matrix 1.2-18 2019-11-27 [2] CRAN (R 4.0.0) ## matrixStats * 0.56.0 2020-03-13 [1] CRAN (R 4.0.0) ## memoise 1.1.0 2017-04-21 [1] CRAN (R 4.0.0) ## modelr 0.1.7 2020-04-30 [1] CRAN (R 4.0.0) ## munsell 0.5.0 2018-06-12 [1] CRAN (R 4.0.0) ## nlme 3.1-147 2020-04-13 [2] CRAN (R 4.0.0) ## org.Dr.eg.db * 3.11.1 2020-05-11 [1] Bioconductor ## pillar 1.4.4 2020-05-05 [1] CRAN (R 4.0.0) ## pkgbuild 1.0.8 2020-05-07 [1] CRAN (R 4.0.0) ## pkgconfig 2.0.3 2019-09-22 [1] CRAN (R 4.0.0) ## pkgload 1.0.2 2018-10-29 [1] CRAN (R 4.0.0) ## png 0.1-7 2013-12-03 [1] CRAN (R 4.0.0) ## prettyunits 1.1.1 2020-01-24 [1] CRAN (R 4.0.0) ## processx 3.4.2 2020-02-09 [1] CRAN (R 4.0.0) ## ps 1.3.3 2020-05-08 [1] CRAN (R 4.0.0) ## purrr * 0.3.4 2020-04-17 [1] CRAN (R 4.0.0) ## R.methodsS3 * 1.8.0 2020-02-14 [1] CRAN (R 4.0.0) ## R.oo * 1.23.0 2019-11-03 [1] CRAN (R 4.0.0) ## R.utils * 2.9.2 2019-12-08 [1] CRAN (R 4.0.0) ## R6 2.4.1 2019-11-12 [1] CRAN (R 4.0.0) ## Rcpp 1.0.4.6 2020-04-09 [1] CRAN (R 4.0.0) ## RCurl 1.98-1.2 2020-04-18 [1] CRAN (R 4.0.0) ## readr * 1.3.1 2018-12-21 [1] CRAN (R 4.0.0) ## readxl 1.3.1 2019-03-13 [1] CRAN (R 4.0.0) ## remotes 2.1.1 2020-02-15 [1] CRAN (R 4.0.0) ## reprex 0.3.0 2019-05-16 [1] CRAN (R 4.0.0) ## rlang 0.4.6 2020-05-02 [1] CRAN (R 4.0.0) ## rmarkdown 2.1 2020-01-20 [1] CRAN (R 4.0.0) ## rprojroot 1.3-2 2018-01-03 [1] CRAN (R 4.0.0) ## RSQLite 2.2.0 2020-01-07 [1] CRAN (R 4.0.0) ## rstudioapi 0.11 2020-02-07 [1] CRAN (R 4.0.0) ## rsvd 1.0.3 2020-02-17 [1] CRAN (R 4.0.0) ## rvest 0.3.5 2019-11-08 [1] CRAN (R 4.0.0) ## S4Vectors * 0.26.0 2020-04-27 [1] Bioconductor ## scales 1.1.1 2020-05-11 [1] CRAN (R 4.0.0) ## scater * 1.16.0 2020-04-27 [1] Bioconductor ## sessioninfo 1.1.1 2018-11-05 [1] CRAN (R 4.0.0) ## SingleCellExperiment * 1.10.1 2020-04-28 [1] Bioconductor ## stringi 1.4.6 2020-02-17 [1] CRAN (R 4.0.0) ## stringr * 1.4.0 2019-02-10 [1] CRAN (R 4.0.0) ## SummarizedExperiment * 1.18.1 2020-04-30 [1] Bioconductor ## testthat 2.3.2 2020-03-02 [1] CRAN (R 4.0.0) ## tibble * 3.0.1 2020-04-20 [1] CRAN (R 4.0.0) ## tidyr * 1.0.3 2020-05-07 [1] CRAN (R 4.0.0) ## tidyselect 1.0.0 2020-01-27 [1] CRAN (R 4.0.0) ## tidyverse * 1.3.0 2019-11-21 [1] CRAN (R 4.0.0) ## usethis 1.6.1 2020-04-29 [1] CRAN (R 4.0.0) ## vctrs 0.2.4 2020-03-10 [1] CRAN (R 4.0.0) ## vipor 0.4.5 2017-03-22 [1] CRAN (R 4.0.0) ## viridis 0.5.1 2018-03-29 [1] CRAN (R 4.0.0) ## viridisLite 0.3.0 2018-02-01 [1] CRAN (R 4.0.0) ## withr 2.2.0 2020-04-20 [1] CRAN (R 4.0.0) ## xfun 0.13 2020-04-13 [1] CRAN (R 4.0.0) ## xml2 1.3.2 2020-04-23 [1] CRAN (R 4.0.0) ## XVector 0.28.0 2020-04-27 [1] Bioconductor ## yaml 2.2.1 2020-02-01 [1] CRAN (R 4.0.0) ## zlibbioc 1.34.0 2020-04-27 [1] Bioconductor ## ## [1] D:/R_packages ## [2] C:/Program Files/R/R-4.0.0/library 3.10 Solutions Construction of SCE and quality control %&gt;% is the pipe operator from the dplyr package. It is very useful when the output of one function acts as an input for another, thus facilitating the chaining of our functions. It saves us from assigning new variables each time. [0-9] means any digit from 0-9 and * means that the preceding expression is repeated for any number of times. Depends. We want to make sure that all the clusterIDs in our dataset are mapped to a corresponding clustername, hence we use left_join. If there is an unmatched clusterID, it will return an NA. In this case, we know that all the clusterIDs in our dataset are present in the txt file, so any join method will work. A cell is an outlier with respect to a metric if it is greater than 3 median absolute deviations MAD "],
["clustering.html", "Chapter 4 Clustering 4.1 Introduction 4.2 Importing libraries 4.3 Importing Data 4.4 Useful seurat object interaction methods 4.5 Performing dimensional reduction 4.6 Clustering 4.7 UMAP with authors’ annotations 4.8 t-SNE with authors’ annotations 4.9 Assigning our own cluster identities 4.10 UMAP visualisation of our annotations 4.11 Highlighting tailbud cells 4.12 Saving RDS object 4.13 Session Info 4.14 Solutions", " Chapter 4 Clustering 4.1 Introduction In part 1), we performed quality control on the cells in our dataset. At this stage, we have discarded 8 cells which have a low number of expressed features and removed 381 features which were not expressed in any cell in the dataset. At the end of our analyses, we saved the following at our workplace: QCed SingleCellExperiment R object (with the .rds file extension) Metadata regarding the cells (clusterID, clusternames etc.) in a csv file In this section, we will demonstrate the normalisation, feature selection, dimensionality reduction and clustering steps of the scRNAseq workflow. To do this, we will take advantage of the Seurat R package which provides numerous convenient wrapper functions that simplify most of the tasks above to just a single(!) function call. Q1) Which steps of the workflow are we executing in this notebook? 4.2 Importing libraries library(SingleCellExperiment) library(Seurat) library(tidyverse) library(gridExtra) library(viridis) library(extrafont) loadfonts(quiet = TRUE) 4.3 Importing Data # Import raw dataset and metadata into seurat. hpf18 &lt;- readRDS(file = &quot;rds/hpf18_QCed_new.rds&quot; ) # Preprocessed dataset Arifrom 1) colData &lt;- read_csv(&quot;./hpf18_coldata.csv&quot;) %&gt;% column_to_rownames(var = &#39;cells&#39;) SCTransform wrapper in seurat implements the following 3 functions sequentially: NormalizeData: In a previous implementation, Seurat normalises the gene measurements for each cell by the total expression in the cell, multiples this by a scale factor (10,000 by default), and then log-transforms the result. More details about the current updated normalisation approach taken by Seurat can be found in the original paper Regularised negative binomial regression Seurat’s mode of normalisation is different from the normalisation method implemented in another popular package (scran) FindVariableFeatures: Identifies the top 3000 features (genes) that show the greatest cell-to-cell variation in the dataset. These genes are used as they serve to highlight the signal in the dataset. ScaleData: Standardises the expression levels of each gene such that: Mean expression of the gene across all cells is 0 Variance of the gene across all cells is 1 so that highly expressed genes do not dominate downstream analysis. Q2) Can you list alternative methods of normalising the data? Q3) Why do we focus on the top few variable features? Q4) What is the purpose of scaling the data? hpf18_seurat &lt;- CreateSeuratObject(counts= counts(hpf18), meta.data = colData) hpf18_seurat &lt;- SCTransform(hpf18_seurat, vars.to.regress = c(&quot;nCount_RNA&quot;, &quot;libraryName&quot;), verbose = FALSE) #Takes about 2 min 30 seconds 4.4 Useful seurat object interaction methods hpf18_seurat[[“RNA”]] # Accessing RNA assay with [[]] notation hpf18_seurat@assays$RNA # Alternative method of accessing assay Key(object = hpf18_seurat) # List the available assays slotNames(hpf18_seurat) DefaultAssay(hpf18_seurat) # Current assay head(Idents(hpf18_seurat)) # All identities GetAssayData(object = hpf18_seurat) Embeddings(object = hpf18_seurat, reduction = “pca”) #Coordinates of cells in low-dimensional space Loadings(object = hpf18_seurat, reduction = “pca”) # Assessing loadings for PCA FetchData(object = hpf18_seurat, vars = c(“PC_1”)) # Retrieves data for a set of cells Complete list of interactions methods 4.5 Performing dimensional reduction Q5) What does PCA stand for and how does it work? Q6) What does t-SNE stand for and how does it work? Q7) What does UMAP stand for and what is the branch of mathematics that underpins it? hpf18_seurat &lt;- RunPCA(hpf18_seurat, pcs.compute = 25, verbose = FALSE) hpf18_seurat &lt;- RunTSNE(hpf18_seurat, dims.use = 1:25, reduction.use = &quot;pca&quot;, perplexity = 76) hpf18_seurat &lt;- RunUMAP(hpf18_seurat, dims = 1:25, min.dist = 0.7, n.neighbors = 30L, verbose = FALSE) 4.6 Clustering The theory underpinning the two seemingly innocuous functions below is dense. We just need to know enough about the important arguments to work with them. If you want more information, the links below provide a comprehensive overview of the key ideas. I will share what I believe is the bare minimum to start working with these functions intelligently. 4.6.1 Constructing a Shared-nearest neighbour (SNN) graph Seurat employs a graph-based clustering method. Of course, this is not the only clustering method available- popular alternatives being hierarchical clustering or simple k-means clustering. 4.6.1.1 Theory To perform graph-based clustering, as the name suggests, we need to construct a graph with our data, where the nodes/vertices in the graph represent our cells and the edge weights between the nodes represent the similarity between the cells involved. How is similarity defined in this context? One possible way to define the similarity between two cells is to calculate their Euclidean distance, that is, by obtaining the square root of the sum of squared differences of each feature value. Remember that each cell is represented as a vector, where each entry is the normalised expression value for a gene. Therefore, we are simply calculating the euclidean distance between two vectors. Another notion of similarity is based on the number of shared neighbours between two cells. This involves two steps: first, we need to determine the number of neighbors (let this number be \\(k\\)) that each cell can have, and obtain this list of k-nearest neighbors. Second, we draw an edge between two cells if they have a neighbor in common (the intersection of the neighborhoods) and weight the edge by how near each of the shared neighbor is to both nodes. Intuitively, if two nodes A and B share a neighbor C that is very close to both of them (C has a high rank in both nodes), then A and B are very similar to each other and this should be reflected in a high edge weight. The latter notion of similarity, based on shared nearest neighbors, is employed in Seurat. Specficially, Seurat uses Jaccard-based weights, in which similarity is defined as the intersection of the neighbors of both cells (shared neighbours) over the union of the neighbors. 4.6.1.2 Practical comments Just as in the k-nearest neighbors algorithm, the number of neighbors, \\(k\\) , considered for each cell is arguably the most important parameter to tinker with. This affects the clustering resolution. A smaller \\(k\\) leads to a finer resolution, with fewer neighbors per cell. 4.6.2 Clustering with the Louvain algorithm Seurat allows us to use a variety of graph-based clustering methods, with the default being the Louvain algorithm. 4.6.2.1 Theory I cannot put it more succinctly than Shanker Iyer in his quora post cited in the resources section below: Communities are groups of nodes within a network that are more densely connected to one another than to other nodes. Modularity is a metric that quantifies the quality of an assignment of nodes to communities by evaluating how much more densely connected the nodes within a community are compared to how connected they would be, on average, in a suitably defined random network. The Louvain method of community detection is an algorithm for detecting communities in networks that relies upon a heuristic for maximizing the modularity. The method consists of repeated application of two steps. The first step is a “greedy” assignment of nodes to communities, favoring local optimizations of modularity. The second step is the definition of a new coarse-grained network in terms of the communities found in the first step. These two steps are repeated until no further modularity-increasing reassignments of communities are possible. 4.6.2.2 Practical comments The resolution parameter is an important parameter to optimize. The smaller the value, the more coarse-grained our clustering, and the fewer clusters are returned. 4.6.3 Resources This powerpoint presentation by Xu and Su summarises their 2015 paper on the shared nearest neighbor algorithm powerpoint Reference The best description I have seen about the louvain algorithm is found in this quora page. The extended description is a real gem. For a more general understanding of clustering in the context of scRNA-seq data, check out our favorite scRNA-seq guide for more details. osca Q8) What are the alternative clustering methods available in seurat? How would you implement them? hpf18_seurat &lt;- Seurat::FindNeighbors(hpf18_seurat, dims = 1:12, k.param = 20, reduction = &quot;pca&quot;, verbose = FALSE) hpf18_seurat &lt;- Seurat::FindClusters(hpf18_seurat, algorithm = 1, resolution = 0.8, verbose = FALSE) 4.7 UMAP with authors’ annotations Idents(hpf18_seurat) &lt;- &quot;clusterID&quot; DimPlot(hpf18_seurat, reduction = &quot;umap&quot;, label= FALSE) (#fig:UMAP with authors clustering)Figure 1- UMAP visualisation of the dataset with the authors labels. The labels appear scattered in the UMAP representation. 4.8 t-SNE with authors’ annotations DimPlot(hpf18_seurat, reduction = &quot;tsne&quot;, label= FALSE) (#fig:TSNE with authors clustering)Figure 2- t-SNE visualisation of the dataset with the authors labels. Each cluster appears to be more homogeneous in the cell labels than the UMAP visualisation, which is consistent with the t-SNE clustering that was performed in the original study. 4.9 Assigning our own cluster identities To match our clustering results with the authors’ cluster annotations, we label each cluster with the cluster name held by the majority of the cells in the cluster (this is what we are doing with the top_n function). We then manually edit the labels for some of the neural clusters that share the same cluster label. Q9) What does the tidyr::complete function do below? Idents(hpf18_seurat) &lt;- &quot;seurat_clusters&quot; clusterIDlabels &lt;- hpf18_seurat@meta.data %&gt;% dplyr::select(clusterNames, seurat_clusters)%&gt;% na.omit() %&gt;% group_by(clusterNames, seurat_clusters) %&gt;% summarize(Cell_Numbers=n())%&gt;% tidyr::complete(seurat_clusters)%&gt;% replace_na(list(Cell_Numbers = 0))%&gt;% group_by(seurat_clusters)%&gt;% top_n(n=1, wt=Cell_Numbers) %&gt;% arrange(seurat_clusters) %&gt;% dplyr::select(seurat_clusters, clusterNames) clusterIDlabels$clusterNames[1:3] &lt;- c(&quot;18hpf-neural - mid-hindbrain&quot;, &quot;18hpf-neural - fore-midbrain&quot;, &quot;18hpf-neural - midbrain &quot;) hpf18_seurat@meta.data$seurat_clusters_names &lt;- clusterIDlabels$clusterNames[match(hpf18_seurat@meta.data$seurat_clusters, clusterIDlabels$seurat_clusters)] labelList &lt;- paste(hpf18_seurat@meta.data$seurat_clusters, hpf18_seurat@meta.data$seurat_clusters_name, sep =&quot;: &quot;) labelList &lt;- gtools::mixedsort(unique(sort(labelList))) 4.10 UMAP visualisation of our annotations cols &lt;- c(scales::hue_pal()(18), &quot;#FFFFFF&quot;) # the number of colors should match the number of clusters DimPlot(hpf18_seurat, label = TRUE, label.size = 4, pt.size=0.1, reduction = &quot;umap&quot;) + scale_color_manual(values = cols, name = &quot;Cluster Identities&quot;, labels = labelList)+ mytheme (#fig:Dim Red Visualisation of my clustering)Figure 3- UMAP visualisation of the dataset with updated labels. 4.11 Highlighting tailbud cells # Selecting cells to highlight cells_PSM &lt;- colnames(hpf18_seurat[,hpf18_seurat@meta.data$seurat_clusters_names == &quot;18hpf-tailbud - PSM&quot;]) cells_TB &lt;- colnames(hpf18_seurat[,hpf18_seurat@meta.data$seurat_clusters_names == &quot;18hpf-tailbud - spinal cord&quot;]) cells_highlighted_TB &lt;- list(cells_PSM, cells_TB) highlighted_names_TB = list(&quot;Unselected&quot;, &quot;18hpf-tailbud - spinal cord&quot;, &quot;18hpf-tailbud - PSM&quot; ) cols_highlight = c(&quot;grey&quot;, &quot;#00BB49&quot;,&quot;#8CAB00&quot;) DimPlot(hpf18_seurat, label = FALSE, label.size = 6, pt.size =0.05, cells.highlight = cells_highlighted_TB)+ scale_color_manual(values = cols_highlight, name = &quot;Cluster Identities&quot;, labels = highlighted_names_TB )+ mytheme ## Scale for &#39;colour&#39; is already present. Adding another scale for &#39;colour&#39;, ## which will replace the existing scale. (#fig:Highlighting tailbud cells)Figure 4- UMAP visualisation of the dataset with the tailbud cells highlighted. 4.12 Saving RDS object saveRDS(hpf18_seurat, file = &quot;./rds/hpf18_seurat_dimred_new.rds&quot; ) 4.13 Session Info View Session Info devtools::session_info() ## - Session info --------------------------------------------------------------- ## setting value ## version R version 4.0.0 (2020-04-24) ## os Windows 10 x64 ## system x86_64, mingw32 ## ui RTerm ## language (EN) ## collate English_United Kingdom.1252 ## ctype English_United Kingdom.1252 ## tz Asia/Kuala_Lumpur ## date 2020-06-04 ## ## - Packages ------------------------------------------------------------------- ## package * version date lib source ## AnnotationDbi * 1.50.0 2020-04-27 [1] Bioconductor ## ape 5.3 2019-03-17 [1] CRAN (R 4.0.0) ## assertthat 0.2.1 2019-03-21 [1] CRAN (R 4.0.0) ## backports 1.1.6 2020-04-05 [1] CRAN (R 4.0.0) ## beeswarm 0.2.3 2016-04-25 [1] CRAN (R 4.0.0) ## Biobase * 2.48.0 2020-04-27 [1] Bioconductor ## BiocGenerics * 0.34.0 2020-04-27 [1] Bioconductor ## BiocNeighbors 1.6.0 2020-04-27 [1] Bioconductor ## BiocParallel 1.22.0 2020-04-27 [1] Bioconductor ## BiocSingular 1.4.0 2020-04-27 [1] Bioconductor ## bit 1.1-15.2 2020-02-10 [1] CRAN (R 4.0.0) ## bit64 0.9-7 2017-05-08 [1] CRAN (R 4.0.0) ## bitops 1.0-6 2013-08-17 [1] CRAN (R 4.0.0) ## blob 1.2.1 2020-01-20 [1] CRAN (R 4.0.0) ## bookdown 0.19 2020-05-15 [1] CRAN (R 4.0.0) ## broom 0.5.6 2020-04-20 [1] CRAN (R 4.0.0) ## callr 3.4.3 2020-03-28 [1] CRAN (R 4.0.0) ## cellranger 1.1.0 2016-07-27 [1] CRAN (R 4.0.0) ## cli 2.0.2 2020-02-28 [1] CRAN (R 4.0.0) ## cluster 2.1.0 2019-06-19 [2] CRAN (R 4.0.0) ## codetools 0.2-16 2018-12-24 [2] CRAN (R 4.0.0) ## colorspace 1.4-1 2019-03-18 [1] CRAN (R 4.0.0) ## cowplot 1.0.0 2019-07-11 [1] CRAN (R 4.0.0) ## crayon 1.3.4 2017-09-16 [1] CRAN (R 4.0.0) ## data.table 1.12.8 2019-12-09 [1] CRAN (R 4.0.0) ## DBI 1.1.0 2019-12-15 [1] CRAN (R 4.0.0) ## dbplyr 1.4.3 2020-04-19 [1] CRAN (R 4.0.0) ## DelayedArray * 0.14.0 2020-04-27 [1] Bioconductor ## DelayedMatrixStats 1.10.0 2020-04-27 [1] Bioconductor ## desc 1.2.0 2018-05-01 [1] CRAN (R 4.0.0) ## devtools 2.3.0 2020-04-10 [1] CRAN (R 4.0.0) ## digest 0.6.25 2020-02-23 [1] CRAN (R 4.0.0) ## dplyr * 0.8.5 2020-03-07 [1] CRAN (R 4.0.0) ## ellipsis 0.3.0 2019-09-20 [1] CRAN (R 4.0.0) ## evaluate 0.14 2019-05-28 [1] CRAN (R 4.0.0) ## extrafont * 0.17 2014-12-08 [1] CRAN (R 4.0.0) ## extrafontdb 1.0 2012-06-11 [1] CRAN (R 4.0.0) ## fansi 0.4.1 2020-01-08 [1] CRAN (R 4.0.0) ## farver 2.0.3 2020-01-16 [1] CRAN (R 4.0.0) ## fitdistrplus 1.0-14 2019-01-23 [1] CRAN (R 4.0.0) ## forcats * 0.5.0 2020-03-01 [1] CRAN (R 4.0.0) ## fs 1.4.1 2020-04-04 [1] CRAN (R 4.0.0) ## future 1.17.0 2020-04-18 [1] CRAN (R 4.0.0) ## future.apply 1.5.0 2020-04-17 [1] CRAN (R 4.0.0) ## generics 0.0.2 2018-11-29 [1] CRAN (R 4.0.0) ## GenomeInfoDb * 1.24.0 2020-04-27 [1] Bioconductor ## GenomeInfoDbData 1.2.3 2020-05-11 [1] Bioconductor ## GenomicRanges * 1.40.0 2020-04-27 [1] Bioconductor ## ggbeeswarm 0.6.0 2017-08-07 [1] CRAN (R 4.0.0) ## ggplot2 * 3.3.0 2020-03-05 [1] CRAN (R 4.0.0) ## ggrepel 0.8.2 2020-03-08 [1] CRAN (R 4.0.0) ## ggridges 0.5.2 2020-01-12 [1] CRAN (R 4.0.0) ## globals 0.12.5 2019-12-07 [1] CRAN (R 4.0.0) ## glue 1.4.0 2020-04-03 [1] CRAN (R 4.0.0) ## gridExtra * 2.3 2017-09-09 [1] CRAN (R 4.0.0) ## gtable 0.3.0 2019-03-25 [1] CRAN (R 4.0.0) ## gtools 3.8.2 2020-03-31 [1] CRAN (R 4.0.0) ## haven 2.2.0 2019-11-08 [1] CRAN (R 4.0.0) ## highr 0.8 2019-03-20 [1] CRAN (R 4.0.0) ## hms 0.5.3 2020-01-08 [1] CRAN (R 4.0.0) ## htmltools 0.4.0 2019-10-04 [1] CRAN (R 4.0.0) ## htmlwidgets 1.5.1 2019-10-08 [1] CRAN (R 4.0.0) ## httr 1.4.1 2019-08-05 [1] CRAN (R 4.0.0) ## ica 1.0-2 2018-05-24 [1] CRAN (R 4.0.0) ## igraph 1.2.5 2020-03-19 [1] CRAN (R 4.0.0) ## IRanges * 2.22.1 2020-04-28 [1] Bioconductor ## irlba 2.3.3 2019-02-05 [1] CRAN (R 4.0.0) ## jsonlite 1.6.1 2020-02-02 [1] CRAN (R 4.0.0) ## KernSmooth 2.23-16 2019-10-15 [2] CRAN (R 4.0.0) ## knitr 1.28 2020-02-06 [1] CRAN (R 4.0.0) ## labeling 0.3 2014-08-23 [1] CRAN (R 4.0.0) ## lattice 0.20-41 2020-04-02 [2] CRAN (R 4.0.0) ## lazyeval 0.2.2 2019-03-15 [1] CRAN (R 4.0.0) ## leiden 0.3.3 2020-02-04 [1] CRAN (R 4.0.0) ## lifecycle 0.2.0 2020-03-06 [1] CRAN (R 4.0.0) ## listenv 0.8.0 2019-12-05 [1] CRAN (R 4.0.0) ## lmtest 0.9-37 2019-04-30 [1] CRAN (R 4.0.0) ## lsei 1.2-0.1 2020-05-06 [1] CRAN (R 4.0.0) ## lubridate 1.7.8 2020-04-06 [1] CRAN (R 4.0.0) ## magrittr 1.5 2014-11-22 [1] CRAN (R 4.0.0) ## MASS 7.3-51.5 2019-12-20 [2] CRAN (R 4.0.0) ## Matrix 1.2-18 2019-11-27 [2] CRAN (R 4.0.0) ## matrixStats * 0.56.0 2020-03-13 [1] CRAN (R 4.0.0) ## memoise 1.1.0 2017-04-21 [1] CRAN (R 4.0.0) ## modelr 0.1.7 2020-04-30 [1] CRAN (R 4.0.0) ## munsell 0.5.0 2018-06-12 [1] CRAN (R 4.0.0) ## nlme 3.1-147 2020-04-13 [2] CRAN (R 4.0.0) ## npsurv 0.4-0.1 2020-05-06 [1] CRAN (R 4.0.0) ## org.Dr.eg.db * 3.11.1 2020-05-11 [1] Bioconductor ## patchwork 1.0.0 2019-12-01 [1] CRAN (R 4.0.0) ## pbapply 1.4-2 2019-08-31 [1] CRAN (R 4.0.0) ## pillar 1.4.4 2020-05-05 [1] CRAN (R 4.0.0) ## pkgbuild 1.0.8 2020-05-07 [1] CRAN (R 4.0.0) ## pkgconfig 2.0.3 2019-09-22 [1] CRAN (R 4.0.0) ## pkgload 1.0.2 2018-10-29 [1] CRAN (R 4.0.0) ## plotly 4.9.2.1 2020-04-04 [1] CRAN (R 4.0.0) ## plyr 1.8.6 2020-03-03 [1] CRAN (R 4.0.0) ## png 0.1-7 2013-12-03 [1] CRAN (R 4.0.0) ## prettyunits 1.1.1 2020-01-24 [1] CRAN (R 4.0.0) ## processx 3.4.2 2020-02-09 [1] CRAN (R 4.0.0) ## ps 1.3.3 2020-05-08 [1] CRAN (R 4.0.0) ## purrr * 0.3.4 2020-04-17 [1] CRAN (R 4.0.0) ## R.methodsS3 * 1.8.0 2020-02-14 [1] CRAN (R 4.0.0) ## R.oo * 1.23.0 2019-11-03 [1] CRAN (R 4.0.0) ## R.utils * 2.9.2 2019-12-08 [1] CRAN (R 4.0.0) ## R6 2.4.1 2019-11-12 [1] CRAN (R 4.0.0) ## RANN 2.6.1 2019-01-08 [1] CRAN (R 4.0.0) ## rappdirs 0.3.1 2016-03-28 [1] CRAN (R 4.0.0) ## RColorBrewer 1.1-2 2014-12-07 [1] CRAN (R 4.0.0) ## Rcpp 1.0.4.6 2020-04-09 [1] CRAN (R 4.0.0) ## RcppAnnoy 0.0.16 2020-03-08 [1] CRAN (R 4.0.0) ## RCurl 1.98-1.2 2020-04-18 [1] CRAN (R 4.0.0) ## readr * 1.3.1 2018-12-21 [1] CRAN (R 4.0.0) ## readxl 1.3.1 2019-03-13 [1] CRAN (R 4.0.0) ## remotes 2.1.1 2020-02-15 [1] CRAN (R 4.0.0) ## reprex 0.3.0 2019-05-16 [1] CRAN (R 4.0.0) ## reshape2 1.4.4 2020-04-09 [1] CRAN (R 4.0.0) ## reticulate 1.15 2020-04-02 [1] CRAN (R 4.0.0) ## rlang 0.4.6 2020-05-02 [1] CRAN (R 4.0.0) ## rmarkdown 2.1 2020-01-20 [1] CRAN (R 4.0.0) ## ROCR 1.0-11 2020-05-02 [1] CRAN (R 4.0.0) ## rprojroot 1.3-2 2018-01-03 [1] CRAN (R 4.0.0) ## RSpectra 0.16-0 2019-12-01 [1] CRAN (R 4.0.0) ## RSQLite 2.2.0 2020-01-07 [1] CRAN (R 4.0.0) ## rstudioapi 0.11 2020-02-07 [1] CRAN (R 4.0.0) ## rsvd 1.0.3 2020-02-17 [1] CRAN (R 4.0.0) ## Rtsne 0.15 2018-11-10 [1] CRAN (R 4.0.0) ## Rttf2pt1 1.3.8 2020-01-10 [1] CRAN (R 4.0.0) ## rvest 0.3.5 2019-11-08 [1] CRAN (R 4.0.0) ## S4Vectors * 0.26.0 2020-04-27 [1] Bioconductor ## scales 1.1.1 2020-05-11 [1] CRAN (R 4.0.0) ## scater * 1.16.0 2020-04-27 [1] Bioconductor ## sctransform 0.2.1 2019-12-17 [1] CRAN (R 4.0.0) ## sessioninfo 1.1.1 2018-11-05 [1] CRAN (R 4.0.0) ## Seurat * 3.1.5 2020-04-16 [1] CRAN (R 4.0.0) ## SingleCellExperiment * 1.10.1 2020-04-28 [1] Bioconductor ## stringi 1.4.6 2020-02-17 [1] CRAN (R 4.0.0) ## stringr * 1.4.0 2019-02-10 [1] CRAN (R 4.0.0) ## SummarizedExperiment * 1.18.1 2020-04-30 [1] Bioconductor ## survival 3.1-12 2020-04-10 [2] CRAN (R 4.0.0) ## testthat 2.3.2 2020-03-02 [1] CRAN (R 4.0.0) ## tibble * 3.0.1 2020-04-20 [1] CRAN (R 4.0.0) ## tidyr * 1.0.3 2020-05-07 [1] CRAN (R 4.0.0) ## tidyselect 1.0.0 2020-01-27 [1] CRAN (R 4.0.0) ## tidyverse * 1.3.0 2019-11-21 [1] CRAN (R 4.0.0) ## tsne 0.1-3 2016-07-15 [1] CRAN (R 4.0.0) ## usethis 1.6.1 2020-04-29 [1] CRAN (R 4.0.0) ## uwot 0.1.8 2020-03-16 [1] CRAN (R 4.0.0) ## vctrs 0.2.4 2020-03-10 [1] CRAN (R 4.0.0) ## vipor 0.4.5 2017-03-22 [1] CRAN (R 4.0.0) ## viridis * 0.5.1 2018-03-29 [1] CRAN (R 4.0.0) ## viridisLite * 0.3.0 2018-02-01 [1] CRAN (R 4.0.0) ## withr 2.2.0 2020-04-20 [1] CRAN (R 4.0.0) ## xfun 0.13 2020-04-13 [1] CRAN (R 4.0.0) ## xml2 1.3.2 2020-04-23 [1] CRAN (R 4.0.0) ## XVector 0.28.0 2020-04-27 [1] Bioconductor ## yaml 2.2.1 2020-02-01 [1] CRAN (R 4.0.0) ## zlibbioc 1.34.0 2020-04-27 [1] Bioconductor ## zoo 1.8-8 2020-05-02 [1] CRAN (R 4.0.0) ## ## [1] D:/R_packages ## [2] C:/Program Files/R/R-4.0.0/library 4.14 Solutions Normalising data, feature selection, dimensionality reduction, clustering. (We don’t have multiple datasets to integrate here) Examples of normalisation strategies include: See osca Library size normalisation (dividing by total counts across all genes for each cell) Normalisation by spike-ins: using the fact that all cells should have the same number of spike-ins and that the spike-in transcripts respond to biases similarly to the endogeneous genes, we can scale each cell by the spike-in counts We assume that biological variation would result in significant variation in the genes of interest. Genes are expressed at different levels. If we do not scale our data, then in subsequent calculations of distance, genes with higher levels of expression will dominate in the analyses. Principal component analysis. PCA is an unsupervised learning technique (similar to t-SNE, UMAP) which is used to reduce the dimension of the dataset with minimum loss of information. It does this by explaining the current predictors with a smaller set of variables called principal components, which are obtained from the original via a simple linear transformation. t-distributed stochastic neighbor embedding. t-SNE is a non-linear (as opposed to PCA) dimensionality reduction method which focuses on preserving the local structure of the data. This means that points that are close to each other on high-dimensional space will also be close to each other on the lower-dimensional projection. It does not, however, preserve global structure. An important parameter to understand is the perplexity parameter, which is the expected density around each point. For more details, watch this amazing youtube video StatQuest Uniform Manifold Approximation and Projection. The branch of mathematics is topology. Leiden algorithm and SLM algorithm. Adjust the algorithm argument in the FindClusters function. It completes the dataset by finding all missing combinations of data. "],
["differentially-expressed-genes.html", "Chapter 5 Differentially Expressed Genes 5.1 Visualisation of marker genes in our dataset 5.2 Obtaining a list of differentially expressed genes 5.3 Analysing output of the wilcoxon test 5.4 Visualising the expression of the marker genes 5.5 Session Info 5.6 Solutions", " Chapter 5 Differentially Expressed Genes 5.1 Visualisation of marker genes in our dataset Genes that are differentially expressed between clusters drive the separation of the clusters. We call these genes the marker genes for the cluster. If the clusters correspond to our biologically meaningful notion of a cell type, then these marker genes are akin to the cell-type specific markers that identifies these cells. By using our existing biological knowledge, we can annotate the function of these genes and use this to assign a cell type identity for each cluster. Alternatively, we can obtain a list of marker genes and check for novel genes that mark the cell type. We can easily assess the accuracy of our clustering by looking at the distribution of known marker genes across the different clusters. For instance, tbx16 and msgn1 mark the nascent presomitic mesoderm whilst sox2 and sox3 are the neuronal markers. library(Seurat) library(tidyverse) library(gridExtra) library(scales) library(extrafont) loadfonts(quiet = TRUE) Q1) What other markers would be interesting to visualise for this dataset? hpf18_seurat &lt;- readRDS(&quot;rds/hpf18_seurat_dimred_new.rds&quot;) hpf18_seurat&lt;- SetIdent(hpf18_seurat, value = hpf18_seurat@meta.data$seurat_clusters_names) markergenes &lt;- c(&quot;tbx16&quot;, &quot;msgn1&quot;, &quot;ta&quot;, &quot;sox2&quot;, &quot;sox3&quot;, &quot;pax6a&quot;, &quot;krt8&quot;, &quot;pfn1&quot;, &quot;krt4&quot;, &quot;pitx1&quot;, &quot;hand2&quot;, &quot;entpd1&quot;) #Visualizing marker genes FeaturePlot(object = hpf18_seurat, features= markergenes, cols = colorspace::sequential_hcl(4, &quot;Viridis&quot;), reduction= &quot;umap&quot;, label = FALSE) Figure 5.1: Figure 1- UMAP visualisation of cells labelled with the expression of marker genes. Q2) What additional information does the violin plot provide over the feature plot? How does the violin plot differ from a box plot? VlnPlot(object = hpf18_seurat, features = markergenes, ncol = 3) (#fig:all_violinplot)Figure 2- Violin plot of the marker genes. 5.2 Obtaining a list of differentially expressed genes Seurat’s FindAllMarkers function allows us to easily compute these DEGs. The important arguments in this function are: only.pos: Setting this to TRUE returns only the marker genes that are upregulated in the cluster. 2.test: This determines the statistical test for differential expression. min.pct: The default is 0.25. This means that it will only test genes that are detected in a minimum fraction of 0.25 cells in either of the 2 clusters being compared. For a complete list, see the documentation Q3) How would you go about comparing a cluster of interest with another cluster? #Obtaining DEGs cells.markers.wilcox &lt;- FindAllMarkers(object = hpf18_seurat, only.pos = TRUE, test = &quot;wilcox&quot;, min.pct = 0.25, thresh.use = 0.25) ## Calculating cluster 18hpf-hatching gland ## Calculating cluster 18hpf-neural crest - grem2 ## Calculating cluster 18hpf-differentiating neurons ## Calculating cluster 18hpf-tailbud - spinal cord ## Calculating cluster 18hpf-epidermal - anterior ## Calculating cluster 18hpf-neural - fore-midbrain ## Calculating cluster 18hpf-pharyngeal arch ## Calculating cluster 18hpf-myotome ## Calculating cluster 18hpf-tailbud - PSM ## Calculating cluster 18hpf-neural - ventral hindbrain ## Calculating cluster 18hpf-epidermal - pfn1 ## Calculating cluster 18hpf-epidermal - sox4b ## Calculating cluster 18hpf-neural - mid-hindbrain ## Calculating cluster 18hpf-erythroid ## Calculating cluster 18hpf-neural - telencephalon ## Calculating cluster 18hpf-macrophage ## Calculating cluster 18hpf-neural - midbrain ## Calculating cluster 18hpf-endothelial write.table(file = &quot;hpf18_wilcoxon.txt&quot;, cells.markers.wilcox, sep = &quot;\\t&quot;) View(cells.markers.wilcox) Q4) Have a go at customizing the heatmap. How would you quickly check for the arguments in the function? top3_wilcox &lt;- cells.markers.wilcox %&gt;% group_by(cluster) %&gt;% top_n(3, avg_logFC) DoHeatmap(object = hpf18_seurat, features = top3_wilcox$gene, label = FALSE) (#fig:DEG heatmap)Figure 3- Heatmap of differentially expressed genes in each cluster of the single-cell data. 5.3 Analysing output of the wilcoxon test Text below taken from Seurat’s differential expression vignette The results data frame has the following columns: p_val : p_val (unadjusted) -bavg_logFC : log fold-chage of the average expression between the two groups. Positive values indicate that the feature is more highly expressed in the first group. pct.1 : The percentage of cells where the feature is detected in the first group pct.2 : The percentage of cells where the feature is detected in the second group p_val_adj : Adjusted p-value, based on bonferroni correction using all features in the dataset. wilcoxon &lt;- read.table(&quot;hpf18_wilcoxon.txt&quot;) wilcoxon &lt;- wilcoxon %&gt;% dplyr::select(gene, cluster, p_val_adj, avg_logFC) %&gt;% dplyr::mutate(test = &quot;wilcoxon&quot;) %&gt;% group_by(cluster) %&gt;% dplyr::arrange(cluster, desc(avg_logFC))%&gt;% top_n(20, avg_logFC) write.csv(wilcoxon, file = &quot;wilcoxon_dim25.csv&quot;) 5.4 Visualising the expression of the marker genes Figure 2b) of Cao et al., 2019- Cluster vs marker gene dot plot hpf18_seurat &lt;- readRDS(&quot;rds/hpf18_seurat_dimred_new.rds&quot;) wilcoxon &lt;- read.table(&quot;hpf18_wilcoxon.txt&quot;) Idents(hpf18_seurat) &lt;- &quot;seurat_clusters_names&quot; features &lt;- wilcoxon %&gt;% filter(!(str_detect(gene, &quot;si:&quot;)|str_detect(gene, &quot;wu:&quot;)|str_detect(gene, &quot;LOC&quot;)|str_detect(gene, &quot;MGC&quot;)|str_detect(gene, &quot;zgc:&quot;))) %&gt;% group_by(cluster)%&gt;% top_n(n=-1, wt= p_val_adj) %&gt;% top_n(n=1, wt=avg_logFC) %&gt;% dplyr::select(cluster,gene) a &lt;- DotPlot(hpf18_seurat, features = features$gene) + #RotatedAxis() + scale_color_gradient2(low = &quot;red&quot;, mid = &quot;white&quot;,high = muted(&quot;blue&quot;), midpoint = 0) + guides(size = guide_legend(title = &#39;Percent of cells in cluster expressing feature&#39;))+ theme_bw(base_size=14) + ylab(&quot;Cluster Name&quot;)+ theme(legend.text=element_text(face=&quot;bold&quot;), plot.title = element_text(hjust = 0.5), text=element_text(family=&quot;Arial&quot;), axis.text.x = element_text(angle = 90, hjust=1)) ## Scale for &#39;colour&#39; is already present. Adding another scale for &#39;colour&#39;, ## which will replace the existing scale. a (#fig:dotplot_all)Figure 4- Dot plot displaying the top marker gene for each cluster. #unique(wilcoxon$cluster) TB_features &lt;- wilcoxon %&gt;% group_by(cluster) %&gt;% filter(cluster == &quot;18hpf-tailbud - spinal cord&quot; | cluster == &quot;18hpf-tailbud - PSM&quot; ) %&gt;% top_n(n=-10, wt= p_val_adj) %&gt;% top_n(n=-10, wt=avg_logFC) %&gt;% dplyr::select(cluster,gene) b &lt;- DotPlot(hpf18_seurat, features = TB_features$gene) + RotatedAxis() + scale_color_gradient2(low = &quot;red&quot;, mid = &quot;white&quot;,high = muted(&quot;blue&quot;), midpoint = 0) + guides(size = guide_legend(title = &#39;Percent of cells in cluster expressing feature&#39;))+ theme_bw(base_size=14) + ylab(&quot;Cluster Name&quot;)+ theme(legend.text=element_text(face=&quot;bold&quot;), plot.title = element_text(hjust = 0.5), text=element_text(family=&quot;Arial&quot;), axis.text.x = element_text(angle = 90, hjust=1)) ## Scale for &#39;colour&#39; is already present. Adding another scale for &#39;colour&#39;, ## which will replace the existing scale. b (#fig:dotplot_TB )Figure 5- Dot plot showing the distribution of the tailbud marker genes across all clusters #DoHeatmap(object = hpf18_seurat_cc, slot = &quot;scale.data&quot;, assay = &quot;SCT&quot;, features = TB_features$gene, size = 3) + RotatedAxis() 5.5 Session Info View Session Info devtools::session_info() ## - Session info --------------------------------------------------------------- ## setting value ## version R version 4.0.0 (2020-04-24) ## os Windows 10 x64 ## system x86_64, mingw32 ## ui RTerm ## language (EN) ## collate English_United Kingdom.1252 ## ctype English_United Kingdom.1252 ## tz Asia/Kuala_Lumpur ## date 2020-06-04 ## ## - Packages ------------------------------------------------------------------- ## package * version date lib source ## AnnotationDbi * 1.50.0 2020-04-27 [1] Bioconductor ## ape 5.3 2019-03-17 [1] CRAN (R 4.0.0) ## assertthat 0.2.1 2019-03-21 [1] CRAN (R 4.0.0) ## backports 1.1.6 2020-04-05 [1] CRAN (R 4.0.0) ## beeswarm 0.2.3 2016-04-25 [1] CRAN (R 4.0.0) ## Biobase * 2.48.0 2020-04-27 [1] Bioconductor ## BiocGenerics * 0.34.0 2020-04-27 [1] Bioconductor ## BiocNeighbors 1.6.0 2020-04-27 [1] Bioconductor ## BiocParallel 1.22.0 2020-04-27 [1] Bioconductor ## BiocSingular 1.4.0 2020-04-27 [1] Bioconductor ## bit 1.1-15.2 2020-02-10 [1] CRAN (R 4.0.0) ## bit64 0.9-7 2017-05-08 [1] CRAN (R 4.0.0) ## bitops 1.0-6 2013-08-17 [1] CRAN (R 4.0.0) ## blob 1.2.1 2020-01-20 [1] CRAN (R 4.0.0) ## bookdown 0.19 2020-05-15 [1] CRAN (R 4.0.0) ## broom 0.5.6 2020-04-20 [1] CRAN (R 4.0.0) ## callr 3.4.3 2020-03-28 [1] CRAN (R 4.0.0) ## cellranger 1.1.0 2016-07-27 [1] CRAN (R 4.0.0) ## cli 2.0.2 2020-02-28 [1] CRAN (R 4.0.0) ## cluster 2.1.0 2019-06-19 [2] CRAN (R 4.0.0) ## codetools 0.2-16 2018-12-24 [2] CRAN (R 4.0.0) ## colorspace 1.4-1 2019-03-18 [1] CRAN (R 4.0.0) ## cowplot 1.0.0 2019-07-11 [1] CRAN (R 4.0.0) ## crayon 1.3.4 2017-09-16 [1] CRAN (R 4.0.0) ## data.table 1.12.8 2019-12-09 [1] CRAN (R 4.0.0) ## DBI 1.1.0 2019-12-15 [1] CRAN (R 4.0.0) ## dbplyr 1.4.3 2020-04-19 [1] CRAN (R 4.0.0) ## DelayedArray * 0.14.0 2020-04-27 [1] Bioconductor ## DelayedMatrixStats 1.10.0 2020-04-27 [1] Bioconductor ## desc 1.2.0 2018-05-01 [1] CRAN (R 4.0.0) ## devtools 2.3.0 2020-04-10 [1] CRAN (R 4.0.0) ## digest 0.6.25 2020-02-23 [1] CRAN (R 4.0.0) ## dplyr * 0.8.5 2020-03-07 [1] CRAN (R 4.0.0) ## ellipsis 0.3.0 2019-09-20 [1] CRAN (R 4.0.0) ## evaluate 0.14 2019-05-28 [1] CRAN (R 4.0.0) ## extrafont * 0.17 2014-12-08 [1] CRAN (R 4.0.0) ## extrafontdb 1.0 2012-06-11 [1] CRAN (R 4.0.0) ## fansi 0.4.1 2020-01-08 [1] CRAN (R 4.0.0) ## farver 2.0.3 2020-01-16 [1] CRAN (R 4.0.0) ## fitdistrplus 1.0-14 2019-01-23 [1] CRAN (R 4.0.0) ## forcats * 0.5.0 2020-03-01 [1] CRAN (R 4.0.0) ## fs 1.4.1 2020-04-04 [1] CRAN (R 4.0.0) ## future 1.17.0 2020-04-18 [1] CRAN (R 4.0.0) ## future.apply 1.5.0 2020-04-17 [1] CRAN (R 4.0.0) ## generics 0.0.2 2018-11-29 [1] CRAN (R 4.0.0) ## GenomeInfoDb * 1.24.0 2020-04-27 [1] Bioconductor ## GenomeInfoDbData 1.2.3 2020-05-11 [1] Bioconductor ## GenomicRanges * 1.40.0 2020-04-27 [1] Bioconductor ## ggbeeswarm 0.6.0 2017-08-07 [1] CRAN (R 4.0.0) ## ggplot2 * 3.3.0 2020-03-05 [1] CRAN (R 4.0.0) ## ggrepel 0.8.2 2020-03-08 [1] CRAN (R 4.0.0) ## ggridges 0.5.2 2020-01-12 [1] CRAN (R 4.0.0) ## globals 0.12.5 2019-12-07 [1] CRAN (R 4.0.0) ## glue 1.4.0 2020-04-03 [1] CRAN (R 4.0.0) ## gridExtra * 2.3 2017-09-09 [1] CRAN (R 4.0.0) ## gtable 0.3.0 2019-03-25 [1] CRAN (R 4.0.0) ## gtools 3.8.2 2020-03-31 [1] CRAN (R 4.0.0) ## haven 2.2.0 2019-11-08 [1] CRAN (R 4.0.0) ## highr 0.8 2019-03-20 [1] CRAN (R 4.0.0) ## hms 0.5.3 2020-01-08 [1] CRAN (R 4.0.0) ## htmltools 0.4.0 2019-10-04 [1] CRAN (R 4.0.0) ## htmlwidgets 1.5.1 2019-10-08 [1] CRAN (R 4.0.0) ## httr 1.4.1 2019-08-05 [1] CRAN (R 4.0.0) ## ica 1.0-2 2018-05-24 [1] CRAN (R 4.0.0) ## igraph 1.2.5 2020-03-19 [1] CRAN (R 4.0.0) ## IRanges * 2.22.1 2020-04-28 [1] Bioconductor ## irlba 2.3.3 2019-02-05 [1] CRAN (R 4.0.0) ## jsonlite 1.6.1 2020-02-02 [1] CRAN (R 4.0.0) ## KernSmooth 2.23-16 2019-10-15 [2] CRAN (R 4.0.0) ## knitr 1.28 2020-02-06 [1] CRAN (R 4.0.0) ## labeling 0.3 2014-08-23 [1] CRAN (R 4.0.0) ## lattice 0.20-41 2020-04-02 [2] CRAN (R 4.0.0) ## lazyeval 0.2.2 2019-03-15 [1] CRAN (R 4.0.0) ## leiden 0.3.3 2020-02-04 [1] CRAN (R 4.0.0) ## lifecycle 0.2.0 2020-03-06 [1] CRAN (R 4.0.0) ## limma 3.44.1 2020-04-28 [1] Bioconductor ## listenv 0.8.0 2019-12-05 [1] CRAN (R 4.0.0) ## lmtest 0.9-37 2019-04-30 [1] CRAN (R 4.0.0) ## lsei 1.2-0.1 2020-05-06 [1] CRAN (R 4.0.0) ## lubridate 1.7.8 2020-04-06 [1] CRAN (R 4.0.0) ## magrittr 1.5 2014-11-22 [1] CRAN (R 4.0.0) ## MASS 7.3-51.5 2019-12-20 [2] CRAN (R 4.0.0) ## Matrix 1.2-18 2019-11-27 [2] CRAN (R 4.0.0) ## matrixStats * 0.56.0 2020-03-13 [1] CRAN (R 4.0.0) ## memoise 1.1.0 2017-04-21 [1] CRAN (R 4.0.0) ## modelr 0.1.7 2020-04-30 [1] CRAN (R 4.0.0) ## munsell 0.5.0 2018-06-12 [1] CRAN (R 4.0.0) ## nlme 3.1-147 2020-04-13 [2] CRAN (R 4.0.0) ## npsurv 0.4-0.1 2020-05-06 [1] CRAN (R 4.0.0) ## org.Dr.eg.db * 3.11.1 2020-05-11 [1] Bioconductor ## patchwork 1.0.0 2019-12-01 [1] CRAN (R 4.0.0) ## pbapply 1.4-2 2019-08-31 [1] CRAN (R 4.0.0) ## pillar 1.4.4 2020-05-05 [1] CRAN (R 4.0.0) ## pkgbuild 1.0.8 2020-05-07 [1] CRAN (R 4.0.0) ## pkgconfig 2.0.3 2019-09-22 [1] CRAN (R 4.0.0) ## pkgload 1.0.2 2018-10-29 [1] CRAN (R 4.0.0) ## plotly 4.9.2.1 2020-04-04 [1] CRAN (R 4.0.0) ## plyr 1.8.6 2020-03-03 [1] CRAN (R 4.0.0) ## png 0.1-7 2013-12-03 [1] CRAN (R 4.0.0) ## prettyunits 1.1.1 2020-01-24 [1] CRAN (R 4.0.0) ## processx 3.4.2 2020-02-09 [1] CRAN (R 4.0.0) ## ps 1.3.3 2020-05-08 [1] CRAN (R 4.0.0) ## purrr * 0.3.4 2020-04-17 [1] CRAN (R 4.0.0) ## R.methodsS3 * 1.8.0 2020-02-14 [1] CRAN (R 4.0.0) ## R.oo * 1.23.0 2019-11-03 [1] CRAN (R 4.0.0) ## R.utils * 2.9.2 2019-12-08 [1] CRAN (R 4.0.0) ## R6 2.4.1 2019-11-12 [1] CRAN (R 4.0.0) ## RANN 2.6.1 2019-01-08 [1] CRAN (R 4.0.0) ## rappdirs 0.3.1 2016-03-28 [1] CRAN (R 4.0.0) ## RColorBrewer 1.1-2 2014-12-07 [1] CRAN (R 4.0.0) ## Rcpp 1.0.4.6 2020-04-09 [1] CRAN (R 4.0.0) ## RcppAnnoy 0.0.16 2020-03-08 [1] CRAN (R 4.0.0) ## RCurl 1.98-1.2 2020-04-18 [1] CRAN (R 4.0.0) ## readr * 1.3.1 2018-12-21 [1] CRAN (R 4.0.0) ## readxl 1.3.1 2019-03-13 [1] CRAN (R 4.0.0) ## remotes 2.1.1 2020-02-15 [1] CRAN (R 4.0.0) ## reprex 0.3.0 2019-05-16 [1] CRAN (R 4.0.0) ## reshape2 1.4.4 2020-04-09 [1] CRAN (R 4.0.0) ## reticulate 1.15 2020-04-02 [1] CRAN (R 4.0.0) ## rlang 0.4.6 2020-05-02 [1] CRAN (R 4.0.0) ## rmarkdown 2.1 2020-01-20 [1] CRAN (R 4.0.0) ## ROCR 1.0-11 2020-05-02 [1] CRAN (R 4.0.0) ## rprojroot 1.3-2 2018-01-03 [1] CRAN (R 4.0.0) ## RSpectra 0.16-0 2019-12-01 [1] CRAN (R 4.0.0) ## RSQLite 2.2.0 2020-01-07 [1] CRAN (R 4.0.0) ## rstudioapi 0.11 2020-02-07 [1] CRAN (R 4.0.0) ## rsvd 1.0.3 2020-02-17 [1] CRAN (R 4.0.0) ## Rtsne 0.15 2018-11-10 [1] CRAN (R 4.0.0) ## Rttf2pt1 1.3.8 2020-01-10 [1] CRAN (R 4.0.0) ## rvest 0.3.5 2019-11-08 [1] CRAN (R 4.0.0) ## S4Vectors * 0.26.0 2020-04-27 [1] Bioconductor ## scales * 1.1.1 2020-05-11 [1] CRAN (R 4.0.0) ## scater * 1.16.0 2020-04-27 [1] Bioconductor ## sctransform 0.2.1 2019-12-17 [1] CRAN (R 4.0.0) ## sessioninfo 1.1.1 2018-11-05 [1] CRAN (R 4.0.0) ## Seurat * 3.1.5 2020-04-16 [1] CRAN (R 4.0.0) ## SingleCellExperiment * 1.10.1 2020-04-28 [1] Bioconductor ## stringi 1.4.6 2020-02-17 [1] CRAN (R 4.0.0) ## stringr * 1.4.0 2019-02-10 [1] CRAN (R 4.0.0) ## SummarizedExperiment * 1.18.1 2020-04-30 [1] Bioconductor ## survival 3.1-12 2020-04-10 [2] CRAN (R 4.0.0) ## testthat 2.3.2 2020-03-02 [1] CRAN (R 4.0.0) ## tibble * 3.0.1 2020-04-20 [1] CRAN (R 4.0.0) ## tidyr * 1.0.3 2020-05-07 [1] CRAN (R 4.0.0) ## tidyselect 1.0.0 2020-01-27 [1] CRAN (R 4.0.0) ## tidyverse * 1.3.0 2019-11-21 [1] CRAN (R 4.0.0) ## tsne 0.1-3 2016-07-15 [1] CRAN (R 4.0.0) ## usethis 1.6.1 2020-04-29 [1] CRAN (R 4.0.0) ## uwot 0.1.8 2020-03-16 [1] CRAN (R 4.0.0) ## vctrs 0.2.4 2020-03-10 [1] CRAN (R 4.0.0) ## vipor 0.4.5 2017-03-22 [1] CRAN (R 4.0.0) ## viridis * 0.5.1 2018-03-29 [1] CRAN (R 4.0.0) ## viridisLite * 0.3.0 2018-02-01 [1] CRAN (R 4.0.0) ## withr 2.2.0 2020-04-20 [1] CRAN (R 4.0.0) ## xfun 0.13 2020-04-13 [1] CRAN (R 4.0.0) ## xml2 1.3.2 2020-04-23 [1] CRAN (R 4.0.0) ## XVector 0.28.0 2020-04-27 [1] Bioconductor ## yaml 2.2.1 2020-02-01 [1] CRAN (R 4.0.0) ## zlibbioc 1.34.0 2020-04-27 [1] Bioconductor ## zoo 1.8-8 2020-05-02 [1] CRAN (R 4.0.0) ## ## [1] D:/R_packages ## [2] C:/Program Files/R/R-4.0.0/library 5.6 Solutions Any marker that you like- that’s part of the exploration! :) The feature plot gives a qualitative view of the expression distribution; the violin plot quantifies the distribution. The violin plot It shows the full distribution of the data, which is especially useful in the case of multimodality (multiple peaks in the data) Use the FindMarkers function. To obtain the DEGs for cluster A against cluster B, set the ident.1 to cluster A and ident.2 to the target cluster B. ?DoHeatmap "],
["exploring-dimensionality-reduction.html", "Chapter 6 Exploring dimensionality reduction 6.1 Load Data 6.2 PCA 6.3 \\(t\\)-stochastic neighbor embedding 6.4 UMAP 6.5 Bibliography", " Chapter 6 Exploring dimensionality reduction library(scater) library(scran) This document is adapted from Orchestrating Single-Cell Analysis. 6.1 Load Data We will use the Zeisel et al. (2015) mouse brain dataset. For simplicity we will load the data as a SingleCellExperiment object from a saved .rds file. This data has already had some basic QC, normalisation, and dimensionality reduction applied. sce.zeisel &lt;- readRDS(&quot;./data/sce.zeisel.rds&quot;) Another application of dimensionality reduction is to compress the data into 2 (sometimes 3) dimensions for plotting. This serves a separate purpose to the PCA-based dimensionality reduction described above. Algorithms are more than happy to operate on 10-50 PCs, but these are still too many dimensions for human comprehension. Further dimensionality reduction strategies are required to pack the most salient features of the data into 2 or 3 dimensions, which we will discuss below. 6.2 PCA We won’t go into the details of PCA here as there are many great visualisations and explanations online. The core idea however is to find the linear subspace which contains most of the variation within the data. The plot below shows the data projected onto the first two principal components (PCs), each point represents a cell, the colours correspond to the cell type annotations provided by the Zeisel et al.. plotReducedDim(sce.zeisel, dimred=&quot;PCA&quot;, colour_by=&quot;level1class&quot;) The simplicity of PCA is both a strength an weakness, because it only finds linear spaces, i.e. variation along straight lines, it can fail to capture important non-linear structure within the data. This is demonstrated in the plot above where different cell-types are not resolved to different coordinates in the first two PCs. A nice feature of PCA is that it naturally provides many more than two dimensions, so while the first two might not resolve the data sufficiently we can gain more of an insight by looking at where the data lies in the other PCs. plotReducedDim(sce.zeisel, dimred=&quot;PCA&quot;, colour_by=&quot;level1class&quot;, ncomponents=4) 6.3 \\(t\\)-stochastic neighbor embedding \\(t\\)-SNE (Van der Maaten and Hinton 2008) is a non-linear method for finding a low-dimensional representation of data. It prioritises maintaining local distances between data-points, the distances between distant populations are not particularly informative. This gives the method more freedom in constructing the low-dimensional space and therefore it often produces better results than PCA. set.seed(100) # runTSNE() stores the t-SNE coordinates in the reducedDims # for re-use across multiple plotReducedDim() calls. sce.zeisel &lt;- runTSNE(sce.zeisel, dimred=&quot;PCA&quot;) plotReducedDim(sce.zeisel, dimred=&quot;TSNE&quot;,colour_by=&quot;level1class&quot;) \\(t\\)-SNE is quite computationally intensive and so it is ordinarily run on the first 50-100 PCA components of the data rather than the raw expression values, this also takes advantage of the denoising that PCA provides. Unlike PCA it is a stochastic method and so, unless a random seed is specified each time, sequential runs of the algorithm will produce different results. set.seed(100) sce.zeisel &lt;- runTSNE(sce.zeisel, dimred=&quot;PCA&quot;) tsne.plot.1 &lt;- plotReducedDim(sce.zeisel, dimred=&quot;TSNE&quot;,colour_by=&quot;level1class&quot;, add_legend=FALSE) sce.zeisel &lt;- runTSNE(sce.zeisel, dimred=&quot;PCA&quot;) tsne.plot.2 &lt;- plotReducedDim(sce.zeisel, dimred=&quot;TSNE&quot;,colour_by=&quot;level1class&quot;, add_legend=FALSE) sce.zeisel &lt;- runTSNE(sce.zeisel, dimred=&quot;PCA&quot;) tsne.plot.3 &lt;- plotReducedDim(sce.zeisel, dimred=&quot;TSNE&quot;,colour_by=&quot;level1class&quot;, add_legend=FALSE) sce.zeisel &lt;- runTSNE(sce.zeisel, dimred=&quot;PCA&quot;) tsne.plot.4 &lt;- plotReducedDim(sce.zeisel, dimred=&quot;TSNE&quot;,colour_by=&quot;level1class&quot;, add_legend=FALSE) multiplot(tsne.plot.1,tsne.plot.2,tsne.plot.3,tsne.plot.4, layout=matrix(seq(4),nrow=2,byrow=TRUE)) Some of these results might be more appealing than others, however it is important to try and avoid ‘cherrypicking’ the plots that conform best to our preconceptions. Furthermore \\(t\\)-SNE also has a number of parameters which can significantly effect the output, they are discussed in depth here. The effect of changing one of these parameters, the perplexity is shown below: set.seed(100) sce.zeisel &lt;- runTSNE(sce.zeisel, dimred=&quot;PCA&quot;, perplexity=5) out5 &lt;- plotReducedDim(sce.zeisel, dimred=&quot;TSNE&quot;,colour_by=&quot;level1class&quot;, add_legend=FALSE) + ggtitle(&quot;perplexity = 5&quot;) set.seed(100) sce.zeisel &lt;- runTSNE(sce.zeisel, dimred=&quot;PCA&quot;, perplexity=20) out20 &lt;- plotReducedDim(sce.zeisel, dimred=&quot;TSNE&quot;,colour_by=&quot;level1class&quot;, add_legend=FALSE) + ggtitle(&quot;perplexity = 20&quot;) set.seed(100) sce.zeisel &lt;- runTSNE(sce.zeisel, dimred=&quot;PCA&quot;, perplexity=80) out80 &lt;- plotReducedDim(sce.zeisel, dimred=&quot;TSNE&quot;, colour_by=&quot;level1class&quot;, add_legend=FALSE) + ggtitle(&quot;perplexity = 80&quot;) multiplot(out5, out20, out80, cols=3) 6.4 UMAP The uniform manifold approximation and projection (UMAP) method (McInnes, Healy, and Melville 2018) is another non-linear dimensionality reduction technique that is becoming increasingly popular. The underlying theory is different to that of \\(t\\)-SNE and the results are different as demonstrated in the plot below. set.seed(100) sce.zeisel &lt;- runUMAP(sce.zeisel, dimred=&quot;PCA&quot;) plotReducedDim(sce.zeisel, dimred=&quot;UMAP&quot;, colour_by=&quot;level1class&quot;) UMAP tends to produce more compact visualisations than \\(t\\)-SNE, preserving more of the global structure. Furthermore it is much faster which can be important for large datasets, a primary reason for its increasing popularity. Like \\(t\\)-SNE it involves random numbers and so setting a seed is important for reproducibility. 6.5 Bibliography McInnes, Leland, John Healy, and James Melville. 2018. “UMAP: Uniform Manifold Approximation and Projection for Dimension Reduction.” arXiv E-Prints, February, arXiv:1802.03426. Van der Maaten, L., and G. Hinton. 2008. “Visualizing Data Using T-SNE.” J. Mach. Learn. Res. 9 (2579-2605): 85. Zeisel, A., A. B. Munoz-Manchado, S. Codeluppi, P. Lonnerberg, G. La Manno, A. Jureus, S. Marques, et al. 2015. “Brain structure. Cell types in the mouse cortex and hippocampus revealed by single-cell RNA-seq.” Science 347 (6226): 1138–42. "],
["exploring-clustering.html", "Chapter 7 Exploring clustering 7.1 Load Data 7.2 Clustering 7.3 k-means 7.4 Graph-based clustering 7.5 Bibliography", " Chapter 7 Exploring clustering library(scater) library(scran) Large sections of this document are adapted from Orchestrating Singe-Cell Analysis. 7.1 Load Data We will use the peripheral blood mononuclear cell (PBMC) dataset from 10X Genomics (Zheng et al. 2017). For simplicity we will load the data as a SingleCellExperiment object from a saved .rds file. This data has already had some basic QC, normalisation, and dimensionality reduction applied. sce.pbmc &lt;- readRDS(&quot;./data/pbmc_preproc.rds&quot;) 7.2 Clustering The most important thing to remember about clustering is that by choosing the right algorithm and representation of our data we can get any groupings we please. Clustering is just one of many tools we have to explore data and the perspectives it offers are only as reasonable as the choices and assumptions that underlie them. 7.3 k-means There are many good explanations and visualisations of how the k-means algorithm works online so I won’t go into much detail here. The objective of the algorithm is to assign each point to a cluster in such a way that minimizes the sum of the squared distances between each point and the average position of all of the points which are assigned to its cluster. set.seed(100) clust.kmeans &lt;- kmeans(reducedDim(sce.pbmc, &quot;PCA&quot;), centers=10) colLabels(sce.pbmc) &lt;- factor(clust.kmeans$cluster) plotReducedDim(sce.pbmc, &quot;TSNE&quot;, colour_by=&quot;label&quot;) + ggtitle(&quot;k-mean Clustering&quot;) Figure 7.1: t-SNE plot of the PBMC dataset, where each point represents a cell and is coloured according to the identity of the assigned cluster from k-means clustering. 7.3.1 Choosing k The key parameter in k-means clustering is choice of the number of clusters, k. By varying this parameter we can move from coarse-grained to more fine-grained clusters. One use of k-means is to deliberately set k to a large value to “overcluster” the data. k-means will happily split up large clusters which graph-based methods try to keep intact, by examining how clusters divide into subclusters can provide some insight on the internal structure of these groups of cells. This is a nice example of the philosophy of using clustering as a tool to interrogate data, rather than a method for ‘objectively’ discovering populations of cells. 7.3.1.1 How do we choose a reasonable k? We can measure how well our clusters fit the variation in the data and use this to inform our choice of a suitable k. One such measure is the gap statistic which is the log-ratio of the expected to observed within-cluster sum of squares. Larger values of the statistic indicate that the chosen number of clusters has better captured the variation present in the data. Often instead of choosing the k with the largest gap statistic we will choose the lowest k with a statistic within some threshold of the best statistic we observe. library(cluster) set.seed(110010101) gaps &lt;- clusGap(reducedDim(sce.pbmc, &quot;PCA&quot;), kmeans, K.max=15) # Choose the smallest k for which the gap statistic is within 1 SE of the best k. best.k &lt;- maxSE(gaps$Tab[,&quot;gap&quot;], gaps$Tab[,&quot;SE.sim&quot;]) plot(gaps$Tab[,&quot;gap&quot;], xlab=&quot;Number of clusters&quot;, ylab=&quot;Gap statistic&quot;) abline(v=best.k, col=&quot;red&quot;) Gap statistic with respect to increasing number of k-means clusters in the PBMC dataset. The red line represents the chosen k. 7.3.2 Which subspace? The k-means algorithm uses the distance between points to cluster them. which the distances between points and centers. However these distances depend on the space in which our points are lying, so which space should we choose? We might choose the ‘full-space’ in which each dimension corresponds to the expression of a different gene. In the case of the pbmc data we have ~30,000 dimensions in our data. It can be quite computationally expensive to work in this full space. Instead we could perform on the data in a reduced dimensionality space such as PCA, \\(t\\)-SNE, or UMAP. Very low dimensional representations of the data such as 2D \\(t\\)-SNE or UMAP cannot include much of the true variation that exists in the data, if we clustered on them directly we would miss important structure in the data. Therefore usually a compromise is made and clustering is performed on the data in the subspace formed by the first 50-100 PCs from PCA, this hopefully has sufficiently many dimensions to contain most of the important structure in the data while not being too computationally expensive to work with. Furthermore by only using the top PCs we denoise the data by discarding less informative variation. After clustering in this higher dimensional space we use the lower dimension \\(t\\)-SNE or UMAP to plot the results. Below we can see the difference between clustering in PCA space vs directly on the two \\(t\\)-SNE dimensions. Note how the mixing of cells with different labels in the PCA space plot contrasts with the clean cluster boundaries from \\(t\\)-SNE clustering. 7.4 Graph-based clustering Graph-based clustering is an increasingly popular family of clustering methods. Instead of directly clustering cells based on their position in a gene expression space these methods use the expression data to build a nearest-neighbours graph and subsequently cluster cells based on the structure of this graph. The graph is constructed by linking each cell to its \\(k\\) nearest neighbours, often weighting the edges by how similar the cells are. This process has better computational scaling than many global methods such as k-means or hierarchical clustering. g &lt;- buildSNNGraph(sce.pbmc, k=10, use.dimred = &#39;PCA&#39;) clust &lt;- igraph::cluster_walktrap(g)$membership colLabels(sce.pbmc) &lt;- factor(clust) plotReducedDim(sce.pbmc, &quot;TSNE&quot;, colour_by=&quot;label&quot;) + ggtitle(&quot;10 nearest neighbours&quot;) There are several important choices to be made when implementing a graph-based clustering method: How many neighbors are considered when constructing the graph. How to weight the edges between connected cells. Once we have the graph which algorithm do we use to detect ‘communities’. For example choosing a lower value of \\(k\\), the number of nearest neighbours to consider when building the graph, tends to produce ‘higher resolution’ clustering, with more clusters detected than if a higher value of \\(k\\) were chosen. As with k-means clustering there is no ‘right answer’ and it is best to use experiment with this parameter to investigate how it effects your results. 7.4.1 Force-directed layout We can directly visualise the underlying graph using a force-directed layout, this effectively provides another dimensionality reduction visualistion alongside \\(t\\)-SNE and UMAP. set.seed(2000) reducedDim(sce.pbmc, &quot;force&quot;) &lt;- igraph::layout_with_fr(g) plotReducedDim(sce.pbmc, colour_by=&quot;label&quot;, dimred=&quot;force&quot;) 7.5 Bibliography Zheng, G. X., J. M. Terry, P. Belgrader, P. Ryvkin, Z. W. Bent, R. Wilson, S. B. Ziraldo, et al. 2017. “Massively parallel digital transcriptional profiling of single cells.” Nat Commun 8 (January): 14049. "],
["optimisations.html", "Chapter 8 Optimisations 8.1 Importing libraries 8.2 Importing Data 8.3 Number of PCs to retain 8.4 Evaluating clustering results 8.5 Comparison with authors’ labels 8.6 Selecting cells for downstream analysis 8.7 Session Info", " Chapter 8 Optimisations 8.1 Importing libraries library(SingleCellExperiment) library(Seurat) library(scran) library(tidyverse) library(scater) library(NMF) library(mclust) library(pheatmap) library(extrafont) loadfonts(quiet = TRUE) 8.2 Importing Data hpf18_seurat &lt;- readRDS(file =&quot;rds/hpf18_seurat_dimred_new.rds&quot;) hpf18_sce &lt;- as.SingleCellExperiment(hpf18_seurat) 8.3 Number of PCs to retain 8.3.1 Scree plot We plot the % of variance explained against the number of principal components. If the top few PCs capture most of the biological signal in our dataset, we expect that there should be a sharp drop between these PCs and the rest of the PCs that capture the technical noise. This drop resembles an ‘elbow’, and hence we are searching for the elbow in the scree plot. In general, methods that involve plotting the % of variance explained against some parameter of interest are called elbow methods, since the point of optimisation is where the said elbow occurs. In very high-dimensional datasets such as ours, it is not uncommon for there to be no clear elbow in the data. ep &lt;- ElbowPlot(hpf18_seurat, ndims = 50, reduction = &quot;pca&quot;) + geom_vline(xintercept = 12, color = &quot;red&quot;, size=1.5, linetype=&quot;dotted&quot;) + ylab(label = &quot;Percentage of variance explained&quot;) + theme_bw() + theme(axis.line = element_line(colour = &quot;black&quot;), panel.grid.major = element_blank(), panel.grid.minor = element_blank(), panel.border = element_blank(), panel.background = element_blank(), text=element_text(family=&quot;Arial&quot;)) ep (#fig:PCA_elbow)Figure 1- Elbow plot for determining the number of principal components. There is a gradual drop in the % of variance explained in the data. The % variance explained for 12 PCs is highlighted by the red line. 8.3.2 Examining technical noise We use the functions available from the scran package in this section. In this alternative method, we first model the mean-variance relationship of the technical noise in our dataset. This is how the relationship would look like, were there to be no biological signal at all. We can do this by a parametric method in the modelGeneVar function. That is to say, we assume the functional form of the noise as a non-linear curve of the form: \\(y = \\frac{ax}{x^n + b}\\) Alternatively, we can make a more stringent assumption that the data trend should follow a poisson distribution. This is implemented in the modelGeneVarByPoisson function. set.seed(2020) ## For reproducibiity ## We fit a non-linear curve to the variances against the means of the data. dec_sce &lt;- scran::modelGeneVar(hpf18_sce) fit_sce &lt;- metadata(dec_sce) plot(fit_sce$mean, fit_sce$var, xlab=&quot;Mean of log-expression&quot;, ylab=&quot;Variance of log-expression&quot;) curve(fit_sce$trend(x), col=&quot;dodgerblue&quot;, add=TRUE, lwd=2) (#fig:PCA_tech_noise)Figure 2- Variance in our dataset against the mean. Each point represents a gene and the blue curve is the fitted trend to all of the genes with a non-linear model. ### Here, we assume that the technical noise can be modelled with a poisson distribution dec_pois_pbmc &lt;- modelGeneVarByPoisson(hpf18_sce) plot(dec_pois_pbmc$mean, dec_pois_pbmc$total, pch=16, xlab=&quot;Mean of log-expression&quot;, ylab=&quot;Variance of log-expression&quot;) curve(metadata(dec_pois_pbmc)$trend(x), col=&quot;dodgerblue&quot;, add=TRUE) (#fig:PCA_tech_poisson)Figure 3- Variance in our dataset against the mean. Each point represents a gene and the blue curve is the fitted trend to all of the genes with a poisson model that is assumed to be the distributional form of the mean-variance relationship. Using the denoisePCA function, we denoise the log-expression data by removing the principal components that correspond to technical noise. denoised_sce&lt;- denoisePCA(hpf18_sce, technical=dec_sce, subset.row=getTopHVGs(dec_sce, prop=0.1)) ncol(reducedDim(denoised_sce)) ## [1] 12 denoised_sce_pois&lt;- denoisePCA(hpf18_sce, technical=dec_pois_pbmc, subset.row=getTopHVGs(dec_pois_pbmc, prop=0.1)) ncol(reducedDim(denoised_sce_pois)) # We hit the cap on the number of PCs ## [1] 50 We can visualise the loadings (coefficients in the linear combination) of the top genes in each principal component with Seurat’s VizDimLoadings function. We can also plot a heatmap for each principal component. This heatmap sorts cells and genes by their principal component scores, allowing us to identify the drivers of variation in each PC. #Seurat::VizDimLoadings(hpf18_seurat, dims = 1:10, reduction = &quot;pca&quot;) Seurat::DimHeatmap(hpf18_seurat, dims = 1:2, cells = 500, balanced = TRUE) (#fig:PCA_dim_visual)Figure 4- PCA heatmaps of the first two components 8.4 Evaluating clustering results The explanation and code below is adapted from osca 8.4.1 Cluster stability Stable clusters are desirable as small changes in our data preprocessing will not cause a major change in the cell assignment. To do this, scran performs sampling with replacement (bootstrap) on the dataset with the bootstrapCluster function and then recomputes the clustering on this newly sampled dataset. The heatmap displays a matrix (we call it \\(A\\)) of coassignment probabilities. The entry \\(A_{ij}\\) in \\(A\\) corresponds to the probability that a randomly chosen cell from cluster \\(i\\) is found in cluster \\(j\\). In the extreme case, a perfect clustering would have a probability of 1 for all diagonal entries, and 0 elsewhere. seurat_clusters &lt;- colData(hpf18_sce)$seurat_clusters myClusterFun &lt;- function(x){ g &lt;- buildSNNGraph(x, use.dimred = &quot;PCA&quot;, type = &quot;jaccard&quot;) igraph::cluster_louvain(g)$membership } set.seed(2020) coassign &lt;- bootstrapCluster(hpf18_sce, FUN = myClusterFun, clusters = seurat_clusters) pheatmap(coassign, cluster_row=FALSE, cluster_col=FALSE, color=rev(viridis::magma(100))) (#fig:clust_stability)Figure 5- Heatmap of coassignment probabilities from bootstrapping of the dataset and reclustering cells 8.4.2 Cluster separability Ideally, our clusters are well-separated from each other. The definition of modularity was provided in chapter 2. In essence, it is the difference between the observed edge weights between nodes belonging to the same cluster and expected edge weights if the edges were wired randomly. A high modulaity score would imply that most edges occur between cells in the same cluster, suggesting that the clusters are well-separated as edges are not formed between cells of different clusters. Recall from our previous discussion that in the SNN graph, an edge is drawn between two cells if they have a neighbor in common. The edge weight describes the degree of similarity via the rank of its shared neighbors. g &lt;- buildSNNGraph(hpf18_sce, use.dimred = &quot;PCA&quot;, type = &quot;jaccard&quot;) ratio &lt;- clusterModularity(g, seurat_clusters, as.ratio = TRUE) pheatmap(log2(ratio+1), cluster_rows=FALSE, cluster_cols=FALSE, color=colorRampPalette(c(&quot;white&quot;, &quot;blue&quot;))(100)) (#fig:clust_separation)Figure 6- Heatmap of the cluster modularity. Each entry along the heatmap diagonal represents the ratio of the total weight between nodes in the same cluster relative to a null model of randomly connected edges. We can create a graph in which the nodes are clusters, instead of cells. Here, a high edge weight is represented by a thicker edge, and corresponds to a greater degree of reallocation of cells between the 2 clusters. cluster.gr &lt;- igraph::graph_from_adjacency_matrix(log2(ratio+1), mode=&quot;upper&quot;, weighted=TRUE, diag=FALSE) # Increasing the weight to increase the visibility of the lines. set.seed(2020) plot(cluster.gr, edge.width=igraph::E(cluster.gr)$weight*10, layout=igraph::layout_with_fr) (#fig:graph_adj)Figure 7- Force-based layout depicting the relationships between clusters. Each node is a cluster, and the edge weight represents the ratio of the observed to expected sum of weights between each pair of clusters. 8.5 Comparison with authors’ labels 8.5.1 Concordance in tailbud cluster assignment In this section, we seek the answer to the question: to what extent does our clustering labels correspond to the authors’ original clustering results? In the original paper, the authors used t-SNE to reduce the dimensions of the data, followed by clustering the cells on this reduced dimensions with density peak clustering. In our pipeline, we utilised Seurat’s approach of first constructing a shared-nearest neighour graph (SNN graph) using the PCA components, prior to clustering with the louvain algorithm, a graph-based clustering method. To what extent are these methods concordant? In the table below, the clusterNames column indicates the cell’s original cluster label. Recall that the identities of these two clusters (tailbud-PSM and tailbud-spinal cord) correspond to the cluster name that occurs most frequently. Therefore, with the exception of a perfect correspondence with the authors’ clusters, we expect that each cluster should be somewhat heterogeneous in the cell labels as some of the cell labels should differ with the assigned cluster labels. The seurat_clusters_names column indicates the assigned cluster name. allLabelsAgainstClusters &lt;- hpf18_seurat@meta.data %&gt;% dplyr::select(clusterNames, seurat_clusters, seurat_clusters_names)%&gt;% na.omit()%&gt;% group_by(clusterNames, seurat_clusters_names) %&gt;% summarize(Cell_Numbers=n())%&gt;% group_by(seurat_clusters_names)%&gt;% dplyr::mutate(Percentage_seurat = Cell_Numbers / sum(Cell_Numbers)*100)%&gt;% dplyr::filter(seurat_clusters_names == &quot;18hpf-tailbud - PSM&quot; | seurat_clusters_names == &quot;18hpf-tailbud - spinal cord&quot;)%&gt;% ungroup()%&gt;% tidyr::complete(clusterNames, seurat_clusters_names, fill = list(Cell_Numbers = 0, Percentage_seurat = 0)) allLabelsAgainstClusters ## # A tibble: 20 x 4 ## clusterNames seurat_clusters_names Cell_Numbers Percentage_seur~ ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 18hpf-epidermal - anteri~ 18hpf-tailbud - PSM 0 0 ## 2 18hpf-epidermal - anteri~ 18hpf-tailbud - spin~ 1 0.450 ## 3 18hpf-neural - dorsal hi~ 18hpf-tailbud - PSM 0 0 ## 4 18hpf-neural - dorsal hi~ 18hpf-tailbud - spin~ 7 3.15 ## 5 18hpf-neural - hindbrain~ 18hpf-tailbud - PSM 0 0 ## 6 18hpf-neural - hindbrain~ 18hpf-tailbud - spin~ 2 0.901 ## 7 18hpf-neural - midbrain 18hpf-tailbud - PSM 2 0.528 ## 8 18hpf-neural - midbrain 18hpf-tailbud - spin~ 0 0 ## 9 18hpf-neural - telenceph~ 18hpf-tailbud - PSM 0 0 ## 10 18hpf-neural - telenceph~ 18hpf-tailbud - spin~ 1 0.450 ## 11 18hpf-neural - ventral h~ 18hpf-tailbud - PSM 1 0.264 ## 12 18hpf-neural - ventral h~ 18hpf-tailbud - spin~ 7 3.15 ## 13 18hpf-notocord 18hpf-tailbud - PSM 2 0.528 ## 14 18hpf-notocord 18hpf-tailbud - spin~ 0 0 ## 15 18hpf-optic cup 18hpf-tailbud - PSM 0 0 ## 16 18hpf-optic cup 18hpf-tailbud - spin~ 2 0.901 ## 17 18hpf-tailbud - PSM 18hpf-tailbud - PSM 371 97.9 ## 18 18hpf-tailbud - PSM 18hpf-tailbud - spin~ 7 3.15 ## 19 18hpf-tailbud - spinal c~ 18hpf-tailbud - PSM 3 0.792 ## 20 18hpf-tailbud - spinal c~ 18hpf-tailbud - spin~ 195 87.8 We visualise our results with a ggplot heatmap using the geom_tile function. a1 &lt;- ggplot(allLabelsAgainstClusters, aes(x = seurat_clusters_names, y = clusterNames, fill = Cell_Numbers)) + geom_tile(aes(fill = Cell_Numbers), size=0.5) + geom_text(aes(label=Cell_Numbers), alpha=1.0, size=3, colour = &quot;gray78&quot;)+ labs(x=&quot;Clusters&quot;,y=&quot;Author&#39;s labels&quot;) a2 &lt;- a1 +viridis::scale_fill_viridis(name = &quot;Cell Number&quot;) + scale_x_discrete(expand=c(0,0), name = &quot;Clusters&quot;, labels = c(&quot;18hpf-tailbud - PSM&quot;, &quot;18hpf-tailbud - spinal cord&quot;))+ theme_bw(base_size=10) + theme(legend.text=element_text(face=&quot;bold&quot;), plot.title = element_text(hjust = 0.5), panel.border=element_blank(), text=element_text(family=&quot;Arial&quot;)) a2 (#fig:concordance heatmap)Figure 8- Heatmap of the authors cell labels against our assigned cluster labels. The majority of cells in our assigned tailbud clusters were also mapped to the same clusters in the authors’ original clustering. 8.5.2 Optimising the seurat clustering parameters One reason why we observe a disparity between the clustering results could be because our chosen parameters were not optimised for the correspondence. In other words, it is possible that the degree of concordance could be improved with a better clustering resolution in the FindClusters function for example. The function below first assigns a clustername to the clusters identified from seurat. Then, we filter for cells that are assigned to the two tailbud clusters, either in our assignment or the authors’ original assignment. Finally, we group cells into one of 3 categories: - Present in the tailbud clusters from our assignment but not in the authors (in_mine_only) - Present in the tailbud clusters from the authors’ dataset but not in ours (in_authors_only) - Present in the tailbud clusters from both approaches (in_both) myoptim &lt;- function(reso,myObj){ myObj &lt;- Seurat::FindNeighbors(hpf18_seurat, dims = 1:12, k.param = 20, reduction = &quot;pca&quot;, verbose = FALSE) myObj &lt;- Seurat::FindClusters(hpf18_seurat, algorithm = 1, resolution = reso, verbose = FALSE) #Finding correspondence between cluster numbers AND authors&#39; labels clusterIDlabels &lt;- myObj@meta.data %&gt;% dplyr::select(clusterNames, seurat_clusters)%&gt;% na.omit() %&gt;% group_by(clusterNames, seurat_clusters) %&gt;% summarize(Cell_Numbers=n())%&gt;% tidyr::complete(seurat_clusters)%&gt;% replace_na(list(Cell_Numbers = 0))%&gt;% group_by(seurat_clusters)%&gt;% top_n(n=1, wt=Cell_Numbers) %&gt;% arrange(seurat_clusters) %&gt;% dplyr::select(seurat_clusters, clusterNames) # Assigning mapping to seurat object myObj@meta.data$seurat_clusters_names &lt;- clusterIDlabels$clusterNames[match(myObj@meta.data$seurat_clusters, clusterIDlabels$seurat_clusters)] # Selecting cells that are either assigned the authors&#39;TB labels OR fall into the TB clusters myObj_subsetted &lt;- myObj@meta.data %&gt;% rownames_to_column(&quot;cell&quot;)%&gt;% dplyr::filter(seurat_clusters_names == &quot;18hpf-tailbud - PSM&quot; | seurat_clusters_names == &quot;18hpf-tailbud - spinal cord&quot; | clusterNames == &quot;18hpf-tailbud - PSM&quot; | clusterNames == &quot;18hpf-tailbud - spinal cord&quot;) %&gt;% dplyr::mutate(WithinTBCluster = ifelse((seurat_clusters_names == &quot;18hpf-tailbud - PSM&quot; |seurat_clusters_names == &quot;18hpf-tailbud - spinal cord&quot;) &amp; !(clusterNames == &quot;18hpf-tailbud - PSM&quot; | clusterNames == &quot;18hpf-tailbud - spinal cord&quot;), &quot;in_mine_only&quot;, ifelse(!(seurat_clusters_names == &quot;18hpf-tailbud - PSM&quot; | seurat_clusters_names == &quot;18hpf-tailbud - spinal cord&quot;) &amp; (clusterNames == &quot;18hpf-tailbud - PSM&quot; | clusterNames == &quot;18hpf-tailbud - spinal cord&quot;), &quot;in_authors_only&quot;, &quot;in_both&quot;)), reso_used = reso) %&gt;% dplyr::select(cell, clusterNames, seurat_clusters_names, WithinTBCluster,reso_used) return (myObj_subsetted) } We provide a range of clustering resolutions to assess their impact on the concordance rate. #Inputting parameters cluster_reso &lt;- c(0.4,0.8, 1.2, 1.6, 2.0, 2.4) myDF &lt;- mapply(myoptim, reso = cluster_reso, MoreArgs = list(myObj=&quot;hpf18_seurat&quot;), SIMPLIFY = FALSE) myDF &lt;- do.call(rbind, myDF) To assess the clustering result, we examine the following two measures: Adjusted Rand Index Entropy clustering_optim &lt;- myDF %&gt;% group_by(reso_used, WithinTBCluster)%&gt;% summarize(numbers = n())%&gt;% mutate(percentage = numbers / sum(numbers) * 100) adjusted_rand_index &lt;- myDF %&gt;% group_by(reso_used) %&gt;% mutate(ARI = adjustedRandIndex(seurat_clusters_names, clusterNames)) %&gt;% dplyr::select(reso_used, ARI) %&gt;% distinct() entropy &lt;- myDF %&gt;% group_by(reso_used)%&gt;% mutate(entropy = NMF::entropy(as.factor(seurat_clusters_names), as.factor(clusterNames), method = &quot;mean&quot;)) %&gt;% dplyr::select(reso_used,entropy) %&gt;% distinct() clustering_optim &lt;- list(adjusted_rand_index, clustering_optim, entropy) %&gt;% purrr::reduce(left_join, by = &quot;reso_used&quot;) clustering_optim$ARI[duplicated(clustering_optim$ARI)] &lt;- NA clustering_optim$entropy[duplicated(clustering_optim$entropy)] &lt;- NA clustering_optim$reso_used &lt;-paste(&quot;res=&quot;, clustering_optim$reso_used) # Adjusting order of factors clustering_optim$WithinTBCluster &lt;- factor(clustering_optim$WithinTBCluster, levels = c(&quot;in_both&quot;, &quot;in_authors_only&quot;, &quot;in_mine_only&quot;)) # Facet plot: proportion falling into diff categories while varying k and res multiplot &lt;- ggplot(clustering_optim, aes(x = WithinTBCluster, y = percentage)) + geom_bar(data = clustering_optim, mapping = aes(fill = WithinTBCluster), stat = &quot;identity&quot;) + facet_wrap(vars(reso_used), ncol=3) + geom_text(aes(label = sprintf(&quot;%.1f&quot;, percentage), group = WithinTBCluster),angle=0, size = 3, position = position_dodge(width = 1),vjust = 0.7, colour = &quot;grey5&quot;,fontface = &quot;bold&quot;) + geom_text(aes(label = ifelse(is.na(ARI), &quot;&quot;, paste(&quot;ARI =&quot;, sprintf(&quot;%.3f&quot;, ARI), sep =&quot; &quot;)), group = reso_used),inherit.aes=FALSE, x = 2.7, y= 80, size =3) + geom_text(aes(label = ifelse(is.na(entropy), &quot;&quot;, paste(&quot;H =&quot;, sprintf(&quot;%.3f&quot;, entropy), sep =&quot; &quot;)), group = reso_used), inherit.aes=FALSE, x = 2.7, y= 70, size =3) + scale_fill_brewer(palette = &quot;Accent&quot;, labels = c(&quot;shared&quot;, &quot;in authors&#39; cluster only&quot;, &quot;in my assigned cluster only&quot;),name = &quot;Cluster Assignments&quot;) + theme_bw()+ theme(axis.text.x = element_text(angle=60, hjust=1),axis.title.x=element_blank(), text=element_text(family=&quot;Arial&quot;)) multiplot (#fig:facet_optim)Figure 9- Facetted bar plots of the cluster assignments across 6 louvain clustering resolutions. The Adjusted rand index and entropy for the cluster assignments are displayed. entropy &lt;- myDF %&gt;% group_by(reso_used)%&gt;% mutate(entropy = NMF::entropy(factor(seurat_clusters_names), clusterNames, method = &quot;mean&quot;)) %&gt;% dplyr::select(reso_used, entropy) %&gt;% distinct() entropyPlot &lt;- ggplot(data = entropy, aes(x = reso_used, y = entropy)) + geom_point(aes(color = as.factor(reso_used)))+ geom_line(alpha = 0.5, linetype = &quot;dotted&quot;) + scale_color_viridis_d(&quot;Louvain\\nResolution&quot;) + scale_x_continuous(breaks = cluster_reso)+ scale_y_continuous(limits = c(0.07,0.3))+ theme_bw()+ theme(axis.text.x = element_text(angle=90, hjust=1, vjust = 1), text=element_text(family=&quot;Arial&quot;)) entropyPlot Figure 8.1: Figure 10- Entropy plot across 6 louvain clustering resolutions. 8.6 Selecting cells for downstream analysis For our downstream analysis, we would like to keep cells that are consistently identifed across both analyses, across all clustering resolutions, to belong to the tailbud cluster. The code below calculates this. #myDF$WithinTBCluster &lt;- as.factor(myDF$WithinTBCluster) labelCount &lt;- myDF %&gt;% group_by(cell, WithinTBCluster)%&gt;% summarize(numbers = n()) %&gt;% filter(WithinTBCluster == &quot;in_both&quot;) max_count &lt;- max(labelCount$numbers) labelCountTable &lt;- table(factor(labelCount$numbers, levels = 0:max_count)) labelCountdf &lt;- data.frame(&quot;Occurences&quot; = 0:max_count, &quot;Number_of_Cells&quot; = as.numeric(labelCountTable)) labelCountdf ## Occurences Number_of_Cells ## 1 0 0 ## 2 1 20 ## 3 2 28 ## 4 3 0 ## 5 4 2 ## 6 5 8 ## 7 6 551 cols &lt;- c(scales::hue_pal()(nrow(labelCountdf)), &quot;#FFFFFF&quot;) labelCountPlot &lt;- ggplot(data = labelCountdf, aes(x=Occurences, y = Number_of_Cells)) + geom_bar(mapping = aes(fill = as.factor(Occurences)), stat = &quot;identity&quot;) + geom_text(aes(label = Number_of_Cells, group = Occurences),angle=0, size = 3, colour = &quot;grey5&quot;, vjust = -0.6, fontface = &quot;bold&quot;) + scale_fill_manual(values = cols) + scale_x_discrete(name = &quot;Total number of iterations&quot; , limits = c(0:max_count)) + ylab(label = &quot;Cell Number&quot;) + scale_y_continuous(expand = c(0, 0), limits = c(0, 600))+ theme_bw() + theme( legend.position = &quot;none&quot;, axis.line = element_line(colour = &quot;black&quot;), panel.grid.major = element_blank(), panel.grid.minor = element_blank(), panel.border = element_blank(), text=element_text(family=&quot;Arial&quot;)) labelCountPlot Figure 8.2: Figure 11- Bar plots of number of cells against the total number of iterations. The height of each bar represents the number of cells that are assigned to the tailbud clusters by both the authors’ and my labels, for a given number of clustering resolutions. For instance, 551 cells were assigned by the authors’ and me to belong to the tailbud cluster across all 6 clustering resolutions. myCells &lt;- labelCount[labelCount$numbers == max_count, ]$cell length(myCells) ## [1] 551 hpf18_seurat$TB &lt;- colnames(hpf18_seurat) %in% myCells # Creating this column to facilitate subclustering in chapter 5. saveRDS(hpf18_seurat, file = &quot;rds/hpf18_seurat_optimized551.rds&quot; ) 8.7 Session Info View Session Info devtools::session_info() ## - Session info --------------------------------------------------------------- ## setting value ## version R version 4.0.0 (2020-04-24) ## os Windows 10 x64 ## system x86_64, mingw32 ## ui RTerm ## language (EN) ## collate English_United Kingdom.1252 ## ctype English_United Kingdom.1252 ## tz Asia/Kuala_Lumpur ## date 2020-06-04 ## ## - Packages ------------------------------------------------------------------- ## package * version date lib source ## AnnotationDbi * 1.50.0 2020-04-27 [1] Bioconductor ## ape 5.3 2019-03-17 [1] CRAN (R 4.0.0) ## assertthat 0.2.1 2019-03-21 [1] CRAN (R 4.0.0) ## backports 1.1.6 2020-04-05 [1] CRAN (R 4.0.0) ## beeswarm 0.2.3 2016-04-25 [1] CRAN (R 4.0.0) ## bibtex 0.4.2.2 2020-01-02 [1] CRAN (R 4.0.0) ## Biobase * 2.48.0 2020-04-27 [1] Bioconductor ## BiocGenerics * 0.34.0 2020-04-27 [1] Bioconductor ## BiocNeighbors 1.6.0 2020-04-27 [1] Bioconductor ## BiocParallel 1.22.0 2020-04-27 [1] Bioconductor ## BiocSingular 1.4.0 2020-04-27 [1] Bioconductor ## bit 1.1-15.2 2020-02-10 [1] CRAN (R 4.0.0) ## bit64 0.9-7 2017-05-08 [1] CRAN (R 4.0.0) ## bitops 1.0-6 2013-08-17 [1] CRAN (R 4.0.0) ## blob 1.2.1 2020-01-20 [1] CRAN (R 4.0.0) ## bookdown 0.19 2020-05-15 [1] CRAN (R 4.0.0) ## broom 0.5.6 2020-04-20 [1] CRAN (R 4.0.0) ## callr 3.4.3 2020-03-28 [1] CRAN (R 4.0.0) ## cellranger 1.1.0 2016-07-27 [1] CRAN (R 4.0.0) ## cli 2.0.2 2020-02-28 [1] CRAN (R 4.0.0) ## cluster * 2.1.0 2019-06-19 [2] CRAN (R 4.0.0) ## codetools 0.2-16 2018-12-24 [2] CRAN (R 4.0.0) ## colorspace 1.4-1 2019-03-18 [1] CRAN (R 4.0.0) ## cowplot 1.0.0 2019-07-11 [1] CRAN (R 4.0.0) ## crayon 1.3.4 2017-09-16 [1] CRAN (R 4.0.0) ## data.table 1.12.8 2019-12-09 [1] CRAN (R 4.0.0) ## DBI 1.1.0 2019-12-15 [1] CRAN (R 4.0.0) ## dbplyr 1.4.3 2020-04-19 [1] CRAN (R 4.0.0) ## DelayedArray * 0.14.0 2020-04-27 [1] Bioconductor ## DelayedMatrixStats 1.10.0 2020-04-27 [1] Bioconductor ## desc 1.2.0 2018-05-01 [1] CRAN (R 4.0.0) ## devtools 2.3.0 2020-04-10 [1] CRAN (R 4.0.0) ## digest 0.6.25 2020-02-23 [1] CRAN (R 4.0.0) ## doParallel 1.0.15 2019-08-02 [1] CRAN (R 4.0.0) ## dplyr * 0.8.5 2020-03-07 [1] CRAN (R 4.0.0) ## dqrng 0.2.1 2019-05-17 [1] CRAN (R 4.0.0) ## edgeR 3.30.0 2020-04-27 [1] Bioconductor ## ellipsis 0.3.0 2019-09-20 [1] CRAN (R 4.0.0) ## evaluate 0.14 2019-05-28 [1] CRAN (R 4.0.0) ## extrafont * 0.17 2014-12-08 [1] CRAN (R 4.0.0) ## extrafontdb 1.0 2012-06-11 [1] CRAN (R 4.0.0) ## fansi 0.4.1 2020-01-08 [1] CRAN (R 4.0.0) ## farver 2.0.3 2020-01-16 [1] CRAN (R 4.0.0) ## fitdistrplus 1.0-14 2019-01-23 [1] CRAN (R 4.0.0) ## FNN 1.1.3 2019-02-15 [1] CRAN (R 4.0.0) ## forcats * 0.5.0 2020-03-01 [1] CRAN (R 4.0.0) ## foreach 1.5.0 2020-03-30 [1] CRAN (R 4.0.0) ## fs 1.4.1 2020-04-04 [1] CRAN (R 4.0.0) ## future 1.17.0 2020-04-18 [1] CRAN (R 4.0.0) ## future.apply 1.5.0 2020-04-17 [1] CRAN (R 4.0.0) ## generics 0.0.2 2018-11-29 [1] CRAN (R 4.0.0) ## GenomeInfoDb * 1.24.0 2020-04-27 [1] Bioconductor ## GenomeInfoDbData 1.2.3 2020-05-11 [1] Bioconductor ## GenomicRanges * 1.40.0 2020-04-27 [1] Bioconductor ## ggbeeswarm 0.6.0 2017-08-07 [1] CRAN (R 4.0.0) ## ggplot2 * 3.3.0 2020-03-05 [1] CRAN (R 4.0.0) ## ggrepel 0.8.2 2020-03-08 [1] CRAN (R 4.0.0) ## ggridges 0.5.2 2020-01-12 [1] CRAN (R 4.0.0) ## globals 0.12.5 2019-12-07 [1] CRAN (R 4.0.0) ## glue 1.4.0 2020-04-03 [1] CRAN (R 4.0.0) ## gridBase 0.4-7 2014-02-24 [1] CRAN (R 4.0.0) ## gridExtra * 2.3 2017-09-09 [1] CRAN (R 4.0.0) ## gtable 0.3.0 2019-03-25 [1] CRAN (R 4.0.0) ## gtools 3.8.2 2020-03-31 [1] CRAN (R 4.0.0) ## haven 2.2.0 2019-11-08 [1] CRAN (R 4.0.0) ## highr 0.8 2019-03-20 [1] CRAN (R 4.0.0) ## hms 0.5.3 2020-01-08 [1] CRAN (R 4.0.0) ## htmltools 0.4.0 2019-10-04 [1] CRAN (R 4.0.0) ## htmlwidgets 1.5.1 2019-10-08 [1] CRAN (R 4.0.0) ## httr 1.4.1 2019-08-05 [1] CRAN (R 4.0.0) ## ica 1.0-2 2018-05-24 [1] CRAN (R 4.0.0) ## igraph 1.2.5 2020-03-19 [1] CRAN (R 4.0.0) ## IRanges * 2.22.1 2020-04-28 [1] Bioconductor ## irlba 2.3.3 2019-02-05 [1] CRAN (R 4.0.0) ## iterators 1.0.12 2019-07-26 [1] CRAN (R 4.0.0) ## jsonlite 1.6.1 2020-02-02 [1] CRAN (R 4.0.0) ## KernSmooth 2.23-16 2019-10-15 [2] CRAN (R 4.0.0) ## knitr 1.28 2020-02-06 [1] CRAN (R 4.0.0) ## labeling 0.3 2014-08-23 [1] CRAN (R 4.0.0) ## lattice 0.20-41 2020-04-02 [2] CRAN (R 4.0.0) ## lazyeval 0.2.2 2019-03-15 [1] CRAN (R 4.0.0) ## leiden 0.3.3 2020-02-04 [1] CRAN (R 4.0.0) ## lifecycle 0.2.0 2020-03-06 [1] CRAN (R 4.0.0) ## limma 3.44.1 2020-04-28 [1] Bioconductor ## listenv 0.8.0 2019-12-05 [1] CRAN (R 4.0.0) ## lmtest 0.9-37 2019-04-30 [1] CRAN (R 4.0.0) ## locfit 1.5-9.4 2020-03-25 [1] CRAN (R 4.0.0) ## lsei 1.2-0.1 2020-05-06 [1] CRAN (R 4.0.0) ## lubridate 1.7.8 2020-04-06 [1] CRAN (R 4.0.0) ## magrittr 1.5 2014-11-22 [1] CRAN (R 4.0.0) ## MASS 7.3-51.5 2019-12-20 [2] CRAN (R 4.0.0) ## Matrix 1.2-18 2019-11-27 [2] CRAN (R 4.0.0) ## matrixStats * 0.56.0 2020-03-13 [1] CRAN (R 4.0.0) ## mclust * 5.4.6 2020-04-11 [1] CRAN (R 4.0.0) ## memoise 1.1.0 2017-04-21 [1] CRAN (R 4.0.0) ## modelr 0.1.7 2020-04-30 [1] CRAN (R 4.0.0) ## munsell 0.5.0 2018-06-12 [1] CRAN (R 4.0.0) ## nlme 3.1-147 2020-04-13 [2] CRAN (R 4.0.0) ## NMF * 0.22.0 2020-02-12 [1] CRAN (R 4.0.0) ## npsurv 0.4-0.1 2020-05-06 [1] CRAN (R 4.0.0) ## org.Dr.eg.db * 3.11.1 2020-05-11 [1] Bioconductor ## patchwork 1.0.0 2019-12-01 [1] CRAN (R 4.0.0) ## pbapply 1.4-2 2019-08-31 [1] CRAN (R 4.0.0) ## pheatmap * 1.0.12 2019-01-04 [1] CRAN (R 4.0.0) ## pillar 1.4.4 2020-05-05 [1] CRAN (R 4.0.0) ## pkgbuild 1.0.8 2020-05-07 [1] CRAN (R 4.0.0) ## pkgconfig 2.0.3 2019-09-22 [1] CRAN (R 4.0.0) ## pkgload 1.0.2 2018-10-29 [1] CRAN (R 4.0.0) ## pkgmaker * 0.31.1 2020-03-19 [1] CRAN (R 4.0.0) ## plotly 4.9.2.1 2020-04-04 [1] CRAN (R 4.0.0) ## plyr 1.8.6 2020-03-03 [1] CRAN (R 4.0.0) ## png 0.1-7 2013-12-03 [1] CRAN (R 4.0.0) ## prettyunits 1.1.1 2020-01-24 [1] CRAN (R 4.0.0) ## processx 3.4.2 2020-02-09 [1] CRAN (R 4.0.0) ## ps 1.3.3 2020-05-08 [1] CRAN (R 4.0.0) ## purrr * 0.3.4 2020-04-17 [1] CRAN (R 4.0.0) ## R.methodsS3 * 1.8.0 2020-02-14 [1] CRAN (R 4.0.0) ## R.oo * 1.23.0 2019-11-03 [1] CRAN (R 4.0.0) ## R.utils * 2.9.2 2019-12-08 [1] CRAN (R 4.0.0) ## R6 2.4.1 2019-11-12 [1] CRAN (R 4.0.0) ## RANN 2.6.1 2019-01-08 [1] CRAN (R 4.0.0) ## rappdirs 0.3.1 2016-03-28 [1] CRAN (R 4.0.0) ## RColorBrewer 1.1-2 2014-12-07 [1] CRAN (R 4.0.0) ## Rcpp 1.0.4.6 2020-04-09 [1] CRAN (R 4.0.0) ## RcppAnnoy 0.0.16 2020-03-08 [1] CRAN (R 4.0.0) ## RCurl 1.98-1.2 2020-04-18 [1] CRAN (R 4.0.0) ## readr * 1.3.1 2018-12-21 [1] CRAN (R 4.0.0) ## readxl 1.3.1 2019-03-13 [1] CRAN (R 4.0.0) ## registry * 0.5-1 2019-03-05 [1] CRAN (R 4.0.0) ## remotes 2.1.1 2020-02-15 [1] CRAN (R 4.0.0) ## reprex 0.3.0 2019-05-16 [1] CRAN (R 4.0.0) ## reshape2 1.4.4 2020-04-09 [1] CRAN (R 4.0.0) ## reticulate 1.15 2020-04-02 [1] CRAN (R 4.0.0) ## rlang 0.4.6 2020-05-02 [1] CRAN (R 4.0.0) ## rmarkdown 2.1 2020-01-20 [1] CRAN (R 4.0.0) ## rngtools * 1.5 2020-01-23 [1] CRAN (R 4.0.0) ## ROCR 1.0-11 2020-05-02 [1] CRAN (R 4.0.0) ## rprojroot 1.3-2 2018-01-03 [1] CRAN (R 4.0.0) ## RSpectra 0.16-0 2019-12-01 [1] CRAN (R 4.0.0) ## RSQLite 2.2.0 2020-01-07 [1] CRAN (R 4.0.0) ## rstudioapi 0.11 2020-02-07 [1] CRAN (R 4.0.0) ## rsvd 1.0.3 2020-02-17 [1] CRAN (R 4.0.0) ## Rtsne 0.15 2018-11-10 [1] CRAN (R 4.0.0) ## Rttf2pt1 1.3.8 2020-01-10 [1] CRAN (R 4.0.0) ## rvest 0.3.5 2019-11-08 [1] CRAN (R 4.0.0) ## S4Vectors * 0.26.0 2020-04-27 [1] Bioconductor ## scales * 1.1.1 2020-05-11 [1] CRAN (R 4.0.0) ## scater * 1.16.0 2020-04-27 [1] Bioconductor ## scran * 1.16.0 2020-04-27 [1] Bioconductor ## sctransform 0.2.1 2019-12-17 [1] CRAN (R 4.0.0) ## sessioninfo 1.1.1 2018-11-05 [1] CRAN (R 4.0.0) ## Seurat * 3.1.5 2020-04-16 [1] CRAN (R 4.0.0) ## SingleCellExperiment * 1.10.1 2020-04-28 [1] Bioconductor ## statmod 1.4.34 2020-02-17 [1] CRAN (R 4.0.0) ## stringi 1.4.6 2020-02-17 [1] CRAN (R 4.0.0) ## stringr * 1.4.0 2019-02-10 [1] CRAN (R 4.0.0) ## SummarizedExperiment * 1.18.1 2020-04-30 [1] Bioconductor ## survival 3.1-12 2020-04-10 [2] CRAN (R 4.0.0) ## testthat 2.3.2 2020-03-02 [1] CRAN (R 4.0.0) ## tibble * 3.0.1 2020-04-20 [1] CRAN (R 4.0.0) ## tidyr * 1.0.3 2020-05-07 [1] CRAN (R 4.0.0) ## tidyselect 1.0.0 2020-01-27 [1] CRAN (R 4.0.0) ## tidyverse * 1.3.0 2019-11-21 [1] CRAN (R 4.0.0) ## tsne 0.1-3 2016-07-15 [1] CRAN (R 4.0.0) ## usethis 1.6.1 2020-04-29 [1] CRAN (R 4.0.0) ## utf8 1.1.4 2018-05-24 [1] CRAN (R 4.0.0) ## uwot 0.1.8 2020-03-16 [1] CRAN (R 4.0.0) ## vctrs 0.2.4 2020-03-10 [1] CRAN (R 4.0.0) ## vipor 0.4.5 2017-03-22 [1] CRAN (R 4.0.0) ## viridis * 0.5.1 2018-03-29 [1] CRAN (R 4.0.0) ## viridisLite * 0.3.0 2018-02-01 [1] CRAN (R 4.0.0) ## withr 2.2.0 2020-04-20 [1] CRAN (R 4.0.0) ## xfun 0.13 2020-04-13 [1] CRAN (R 4.0.0) ## xml2 1.3.2 2020-04-23 [1] CRAN (R 4.0.0) ## xtable 1.8-4 2019-04-21 [1] CRAN (R 4.0.0) ## XVector 0.28.0 2020-04-27 [1] Bioconductor ## yaml 2.2.1 2020-02-01 [1] CRAN (R 4.0.0) ## zlibbioc 1.34.0 2020-04-27 [1] Bioconductor ## zoo 1.8-8 2020-05-02 [1] CRAN (R 4.0.0) ## ## [1] D:/R_packages ## [2] C:/Program Files/R/R-4.0.0/library "],
["subclustering.html", "Chapter 9 Subclustering 9.1 Importing libraries 9.2 Importing Data 9.3 Subclustering the TB cells - Using only cells that are assigned to the ‘shared’ cluster across all the clustering resolutions. 9.4 Dimensional reduction with UMAP and clustering 9.5 Identifying marker genes for each cluster 9.6 Merging clusters that do not appear distinct 9.7 Plotting UMAP and assigning cluster labels 9.8 Checking the marker genes for each cluster 9.9 Sox2 tbxta coexpression 9.10 Viewing genes of interest with a dotplot 9.11 Exporting the violin plots for genes of interest. 9.12 Saving RDS object 9.13 Session Info 9.14 Solutions", " Chapter 9 Subclustering 9.1 Importing libraries library(Seurat) library(tidyverse) library(RColorBrewer) 9.2 Importing Data hpf18_seurat &lt;- readRDS(file = &quot;rds/hpf18_seurat_optimized551.rds&quot; ) 9.3 Subclustering the TB cells - Using only cells that are assigned to the ‘shared’ cluster across all the clustering resolutions. TBcells &lt;- subset(hpf18_seurat, subset = TB == TRUE) TBcells ## An object of class Seurat ## 60208 features across 551 samples within 2 assays ## Active assay: SCT (29912 features, 3000 variable features) ## 1 other assay present: RNA ## 3 dimensional reductions calculated: pca, tsne, umap 9.4 Dimensional reduction with UMAP and clustering # Running PCA TBcells &lt;- RunPCA(TBcells, npcs = 50) ## PC_ 1 ## Positive: apoc1l, msgn1, fn1b, tbx24, tbx6, myf5, her1, apoeb, si:dkey-103d23.5, itm2cb ## tbx16, hoxd12a, her7, hm:zewp0073, actc1a, cdx4, LOC103910167, cxcl12b, tuba8l2, wu:fb77a09 ## tcf15, efemp2b, hes6, meox1, phkg2, zgc:56585, foxc1a, cyp26a1, hoxb10a, kif26ab ## Negative: tmsb4x, id1, actb2, fosab, fabp3, krt8, rrm2, prtga, her15.1, junbb ## her2, wu:fb18c02, nova2, marcksl1b, pcna, zfp36l1a, LOC100534909, epcam, wu:fb25b09, elavl3 ## pfn1, krt18, cfl1l, krt4, mdka, jun, sox3, tuba1a, atf3, her6 ## PC_ 2 ## Positive: cdx4, hoxd12a, wnt8-2, wnt8a, hoxc13a, cyp26a1, hoxc13b, LOC103910167, kif26ab, sp5l ## LOC100001360, hoxb9a, scg3, eve1, her12, ldlrad2, cx43.4, ta, hes6, itm2cb ## fgf8a, tbx16, ptmab, hoxd9a, hoxa9b, angptl2b, hoxa13b, phkg2, hoxa10b, tbx6 ## Negative: tbx24, hm:zewp0073, actc1a, efemp2b, hsp90aa1.1, apoc1l, meox1, tcf15, fn1b, myf5 ## apoeb, LOC101886965, ripply1, wif1, ripply2, cpn1, LOC101886882, ntd5, kazald2, mespab ## LOC100535159, si:dkey-103d23.5, tuba8l2, net1, unc45b, rbm24a, aldh1a2, ppap2a, LOC100536992, dmrt2a ## PC_ 3 ## Positive: msgn1, tbx6, itm2cb, tbx16, cyp26a1, hoxc13b, phkg2, hes6, snai1a, wu:fb77a09 ## rbm38, hoxc13a, fn1a, ved, mgat4b, actb2, her1, aplnrb, tmsb4x, tob1a ## palld, her7, cacna2d4a, wnt8-2, wnt8a, krt8, si:dkey-261h17.1, foxc1a, hoxa13a, ephb3 ## Negative: ldlrad2, LOC100001360, scg3, LOC103910167, efemp2b, hoxb9a, wnt11r, hsp90aa1.1, her12, tcf15 ## hoxc3a, si:dkey-103d23.5, meox1, LOC101886965, ppp2r2ca, zic2a, LOC103911885, LOC101882117, olig4, alcamb ## cdx4, LOC101886882, ripply1, col5a2a, bicc2, si:ch211-170d8.2, her3, hspb1, cdh6, hm:zewp0073 ## PC_ 4 ## Positive: wnt8-2, wnt8a, fgf8a, hoxc13b, ta, LOC101886965, efemp2b, cyp26a1, LOC101886882, eve1 ## hoxc13a, LOC100535159, cpn1, aldh1a2, tagln3b, thbs4b, kif26ab, hoxa13b, sp5l, kazald2 ## ripply1, hsp90aa1.1, angptl7, myod1, ppap2a, LOC100536992, rdh10a, zgc:158328, apela, rprmb ## Negative: msgn1, tbx24, ism1, tbx6, her1, ldlrad2, foxc1a, her7, wnt11r, tbx16 ## zgc:56585, ripply2, hoxb1b, apoeb, palld, lbx2, wif1, phc2a, si:dkey-103d23.5, LOC100334443 ## foxc1b, LOC561719, igsf9, scg3, mgat4b, dact2, zic3, itm2cb, cacna2d4a, her2 ## PC_ 5 ## Positive: her7, her1, ripply2, mespab, her12, apoeb, tbx24, hoxc13a, wif1, dlc ## her11, LOC101883520, mespaa, LOC557301, hoxc13b, fgf8a, ta, hoxb7a, eve1, dld ## hoxa13b, sp5l, hoxa13a, ntd5, fkbp7, hoxc3a, tagln3b, wnt8a, wnt8-2, net1 ## Negative: si:dkey-103d23.5, ephb3, mgat4b, fn1b, cacna2d4a, LOC103910167, LOC100006216, itm2cb, tbx6, angptl7 ## LOC103911885, si:ch211-168h21.3, ppp2r2ca, LOC100537766, thbs4b, LOC103908989, tbx16, foxc1a, zgc:123035, phkg2 ## LOC101886965, cpn1, cdx1a, msgn1, crabp2b, rdh10a, zgc:162707, her15.1, uncx4.1, tgfbi # Elbow plot to determine number of PCs for dimension reduction ep &lt;- ElbowPlot(TBcells, ndims = 50, reduction = &quot;pca&quot;) + geom_vline(xintercept = 25, color = &quot;red&quot;, size=1.5, linetype=&quot;dotted&quot;) + ylab(label = &quot;Percentage of variance explained&quot;) + theme_bw() + theme(axis.line = element_line(colour = &quot;black&quot;), panel.grid.major = element_blank(), panel.grid.minor = element_blank(), panel.border = element_blank(), panel.background = element_blank(), text=element_text(family=&quot;Arial&quot;)) # UMAP embedding and clustering ep TBcells &lt;- RunUMAP(TBcells, dims = 1:25, min.dist = 0.7, n.neighbors = 30L, verbose = TRUE) ## 13:12:39 UMAP embedding parameters a = 0.3208 b = 1.563 ## 13:12:39 Read 551 rows and found 25 numeric columns ## 13:12:39 Using Annoy for neighbor search, n_neighbors = 30 ## 13:12:39 Building Annoy index with metric = cosine, n_trees = 50 ## 0% 10 20 30 40 50 60 70 80 90 100% ## [----|----|----|----|----|----|----|----|----|----| ## **************************************************| ## 13:12:39 Writing NN index file to temp file C:\\Users\\User\\AppData\\Local\\Temp\\RtmpABvYpF\\file46b81687bc1 ## 13:12:39 Searching Annoy index using 1 thread, search_k = 3000 ## 13:12:39 Annoy recall = 100% ## 13:12:40 Commencing smooth kNN distance calibration using 1 thread ## 13:12:40 Initializing from normalized Laplacian + noise ## 13:12:40 Commencing optimization for 500 epochs, with 20478 positive edges ## 13:12:42 Optimization finished TBcells &lt;- Seurat::FindNeighbors(TBcells, dims = 1:25, k.param = 20, verbose = FALSE) TBcells &lt;- Seurat::FindClusters(TBcells, algorithm = 1, resolution = 1, verbose = FALSE) 9.5 Identifying marker genes for each cluster # Setting identity for cells to seurat clustering results TBcells&lt;- SetIdent(TBcells, value = TBcells@meta.data$seurat_clusters) all_clusters &lt;- FindAllMarkers(TBcells, test.use = &quot;wilcox&quot;, only.pos = TRUE) %&gt;% group_by(cluster)%&gt;% filter(p_val_adj &lt; 0.05)%&gt;% arrange(cluster, desc(abs(avg_logFC)),p_val_adj) ## Calculating cluster 0 ## Calculating cluster 1 ## Calculating cluster 2 ## Calculating cluster 3 ## Calculating cluster 4 ## Calculating cluster 5 ## Calculating cluster 6 ## Calculating cluster 7 #write.csv(all_clusters,file = &quot;Files/2g)MarkerGenes_9Clusters.csv&quot;) # Viewing number of cells in each cluster table(TBcells@meta.data$seurat_clusters) ## ## 0 1 2 3 4 5 6 7 ## 103 90 76 73 62 50 50 47 # Plot a heatmap to visualize the top 7 marker genes in each cluster. top7_wilcox &lt;- all_clusters %&gt;% group_by(cluster) %&gt;% top_n(7, avg_logFC) DoHeatmap(object = TBcells, features = as.character(top7_wilcox$gene), label = FALSE) + theme(legend.title = element_text(size = 25), axis.line=element_blank(), axis.text.x=element_blank(), axis.text.y = element_text(size = 15), axis.ticks=element_blank(), axis.title.x=element_blank(), axis.title.y=element_blank(), legend.text=element_text(face=&quot;bold&quot;, size = 25), text=element_text(family=&quot;Arial&quot;)) #ggsave(&quot;2g)AllClusters_markerGeneHeatmap.tiff&quot;, hm, dpi = 500, width = 17, height = 17,units = c(&quot;cm&quot;)) top7_wilcox ## # A tibble: 56 x 7 ## # Groups: cluster [8] ## p_val avg_logFC pct.1 pct.2 p_val_adj cluster gene ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;fct&gt; &lt;chr&gt; ## 1 5.41e-54 1.55 0.796 0.118 1.62e-49 0 gfap ## 2 8.71e-29 1.44 0.689 0.201 2.60e-24 0 slc1a3a ## 3 1.69e-31 1.41 0.893 0.44 5.06e-27 0 prtga ## 4 5.01e-44 1.30 0.816 0.181 1.50e-39 0 wnt11r ## 5 3.60e-42 1.28 0.903 0.268 1.08e-37 0 nova2 ## 6 3.88e-42 1.27 0.854 0.219 1.16e-37 0 sox3 ## 7 7.61e-22 1.13 0.932 0.766 2.28e-17 0 mdka ## 8 6.98e-16 1.13 0.922 0.482 2.09e-11 1 actc1a ## 9 8.80e-16 1.12 0.922 0.482 2.63e-11 1 hm:zewp0073 ## 10 7.98e-26 0.954 1 0.62 2.39e-21 1 fn1b ## # ... with 46 more rows 9.6 Merging clusters that do not appear distinct # Merging the two mesodermal clusters 1 and 4 meso &lt;- subset(x = TBcells, subset = (seurat_clusters == &quot;1&quot; | seurat_clusters == &quot;5&quot;)) meso_ids &lt;- rownames(meso@meta.data) TBcells@meta.data$seurat_clusters[rownames(TBcells@meta.data) %in% meso_ids] &lt;- 1 9.7 Plotting UMAP and assigning cluster labels labelList &lt;- data.frame(clusterID = c(0,1,2,3,4,6,7), clusterNames = c(&quot;Posterior NT&quot;, &quot;Posterior PSM&quot;, &quot;Nascent somites&quot;, &quot;Pou5f3+ Posterior NT&quot;, &quot;Maturation zone&quot;, &quot;Tail somites&quot;, &quot;NMps&quot;)) TBcells$subclusters_names &lt;- labelList$clusterNames[match(TBcells$seurat_clusters, labelList$clusterID)] TBcells$subclusters_names &lt;- factor(TBcells$subclusters_names) TBcells&lt;- SetIdent(TBcells, value = TBcells@meta.data$subclusters_names) 9.8 Checking the marker genes for each cluster marker_genes &lt;- c(&quot;sox2&quot;, &quot;ta&quot;, &quot;pou5f3&quot;, &quot;olig4&quot;, &quot;zic5&quot;,&quot;tbx6&quot;, &quot;tbx16&quot;,&quot;msgn1&quot;,&quot;meox1&quot;, &quot;mespab&quot;, &quot;cyp26a1&quot;, &quot;ripply1&quot;) VlnPlot(object = TBcells, features = marker_genes, ncol = 3) # Plotting UMAP dimplot with cluster labels cols &lt;- c(scales::hue_pal()(7), &quot;#FFFFFF&quot;) DimPlot(TBcells, label = TRUE, label.size = 5, pt.size=0.6)+ scale_color_manual(values = cols, name = &quot;Cluster Identities&quot;)+ mytheme #ggsave(&quot;2g)TBsubset.tiff&quot;, tbsubset_plt, dpi = 500, width = 17, height = 13,units = c(&quot;cm&quot;)) #saveRDS(TBcells, file = &quot;rds/2g)TBcells_24.10.19.rds&quot;) 9.9 Sox2 tbxta coexpression # Plotting co-expression of sox2 and ta in TBcells FeaturePlot(TBcells, features = c(&quot;sox2&quot;, &quot;ta&quot;), blend = TRUE, pt.size = 1, blend.threshold = 0.5) #ggsave(&quot;2g)sox2_ta_coexp.tiff&quot;, coexp, dpi = 400, width = 12, height = 6,units = c(&quot;cm&quot;)) 9.10 Viewing genes of interest with a dotplot # Looking at only cells in the NM decision TBcells_nmdecision &lt;- subset(TBcells, subset = subclusters_names == &quot;Neuromesodermal Progenitors&quot; | subclusters_names == &quot;Maturation zone&quot; | subclusters_names == &quot;Pou5f3+ Posterior NT&quot; | subclusters_names == &quot;Posterior NT&quot;) # Specifying genes to visualize nm_genes &lt;- c(&quot;cyp26a1&quot;,&quot;eve1&quot;,&quot;fgf8a&quot;,&quot;hoxa13b&quot;,&quot;hoxc13a&quot;,&quot;hoxc13b&quot;,&quot;sox2&quot;,&quot;ta&quot;,&quot;wnt8a&quot;) meso_genes &lt;- c(&quot;aldh1a2&quot;, &quot;apoc1l&quot;,&quot;bmp10&quot;, &quot;her1&quot;, &quot;her7&quot;, &quot;msgn1&quot;,&quot;snai1a&quot;,&quot;tbx6&quot;,&quot;tbx16&quot;,&quot;tbx24&quot;,&quot;uncx4.1&quot;, &quot;meox1&quot;, &quot;mespab&quot;) neural_genes &lt;- c(&quot;gfap&quot;, &quot;sox3&quot;, &quot;prtga&quot;, &quot;zic2a&quot;, &quot;zic5&quot;) DotPlot(TBcells, features = nm_genes) + theme(text = element_text(size = 8), axis.text.y = element_text(size = 8), axis.text.x = element_text(size = 8, angle = 35)) DotPlot(TBcells, features = meso_genes) + theme(text = element_text(size = 8), axis.text.y = element_text(size = 8), axis.text.x = element_text(size = 8, angle = 35)) DotPlot(TBcells, features = neural_genes) + theme(text = element_text(size = 8), axis.text.y = element_text(size = 8), axis.text.x = element_text(size = 8, angle = 35)) Q1) How would you save the images in the working directory? 9.11 Exporting the violin plots for genes of interest. We loop over each violin plot using the lapply function, which merits additional comment.The apply family of functions is very useful to perform an action repeatedly on a collection of objects such as a dataframe, vector, list etc. Normally iteration is done with a for loop, which is rather time-consuming. The apply function performs the iteration without the explicit use of a for loop. lapply returns a list. Q2) What is the difference between lapply and sapply? # Looking at expression of nmp markers over all clusters in individual violinPlots nmp_markers &lt;- c( &quot;fgf8a&quot;, &quot;wnt8-2&quot;, &quot;wnt8a&quot;, &quot;ta&quot;, &quot;apela&quot;, &quot;eve1&quot;, &quot;ndnf&quot;, &quot;cyp26a1&quot;, &quot;hoxc13b&quot;, &quot;id3&quot;, &quot;hoxc13a&quot;, &quot;thbs2&quot;, &quot;sp5l&quot;, &quot;tagln3b&quot;, &quot;mcamb&quot;, &quot;her12&quot;, &quot;hoxa13b&quot;, &quot;hoxd12a&quot;, &quot;kif26ab&quot;, &quot;sox2&quot;, &quot;prickle1b&quot;, &quot;si:dkey-261h17.1&quot;, &quot;cdh6&quot;, &quot;cx43.4&quot;, &quot;zgc:158328&quot;, &quot;fndc3ba&quot;, &quot;mnx1&quot;, &quot;hes6&quot;, &quot;znf703&quot;, &quot;ube2e2&quot;, &quot;angptl2b&quot;, &quot;depdc7&quot;, &quot;efhd2&quot;, &quot;kdm6a&quot;, &quot;nradd&quot;, &quot;enc1&quot;, &quot;snai1a&quot;, &quot;arf1&quot;, &quot;flrt3&quot;, &quot;phgdh&quot;, &quot;traf4a&quot;, &quot;wls&quot;, &quot;sepn1&quot;, &quot;esrrga&quot;, &quot;ptmab&quot;, &quot;ptbp1b&quot;, &quot;ptmaa&quot;, &quot;mgat1b&quot;, &quot;ubl3a&quot;, &quot;sall4&quot;, &quot;tuba8l4&quot;, &quot;hoxd13a&quot;, &quot;LOC100537138&quot;, &quot;nog2&quot;, &quot;h3f3a&quot;, &quot;myclb&quot;, &quot;sult6b1&quot;, &quot;galnt2&quot;, &quot;fgf4&quot;, &quot;foxa&quot;, &quot;bbc3&quot;, &quot;hoxd11a&quot;, &quot;rcn3&quot;, &quot;plk4&quot;, &quot;foxd3&quot;, &quot;pip5k1ca&quot;, &quot;sec22bb&quot;, &quot;slc12a7b&quot;, &quot;marveld1&quot;, &quot;pcp4a&quot; ) #write.table(nmp_markers, file = &quot;nmp_markergenes.txt&quot;) plots &lt;- VlnPlot(object = TBcells, features =nmp_markers, combine = FALSE) plots &lt;- lapply(X = plots, FUN = function(x) x + theme(plot.title = element_text(size = 30), text = element_text(size = 15), axis.text.y = element_text(size = 12), axis.text.x = element_text(size = 12, angle = 35))) for (i in 1:length(plots)) { ggsave(plot = plots[[i]], path = &quot;violin_plots&quot;, filename = paste0(&quot;violin_&quot;,nmp_markers[i],&quot;.png&quot;), width = 14, height = 10, units = &quot;cm&quot;) } 9.12 Saving RDS object saveRDS(TBcells, file = &quot;rds/TBcells_subclustered.rds&quot;) 9.13 Session Info View Session Info devtools::session_info() ## - Session info --------------------------------------------------------------- ## setting value ## version R version 4.0.0 (2020-04-24) ## os Windows 10 x64 ## system x86_64, mingw32 ## ui RTerm ## language (EN) ## collate English_United Kingdom.1252 ## ctype English_United Kingdom.1252 ## tz Asia/Kuala_Lumpur ## date 2020-06-04 ## ## - Packages ------------------------------------------------------------------- ## package * version date lib source ## AnnotationDbi * 1.50.0 2020-04-27 [1] Bioconductor ## ape 5.3 2019-03-17 [1] CRAN (R 4.0.0) ## assertthat 0.2.1 2019-03-21 [1] CRAN (R 4.0.0) ## backports 1.1.6 2020-04-05 [1] CRAN (R 4.0.0) ## beeswarm 0.2.3 2016-04-25 [1] CRAN (R 4.0.0) ## bibtex 0.4.2.2 2020-01-02 [1] CRAN (R 4.0.0) ## Biobase * 2.48.0 2020-04-27 [1] Bioconductor ## BiocGenerics * 0.34.0 2020-04-27 [1] Bioconductor ## BiocNeighbors 1.6.0 2020-04-27 [1] Bioconductor ## BiocParallel 1.22.0 2020-04-27 [1] Bioconductor ## BiocSingular 1.4.0 2020-04-27 [1] Bioconductor ## bit 1.1-15.2 2020-02-10 [1] CRAN (R 4.0.0) ## bit64 0.9-7 2017-05-08 [1] CRAN (R 4.0.0) ## bitops 1.0-6 2013-08-17 [1] CRAN (R 4.0.0) ## blob 1.2.1 2020-01-20 [1] CRAN (R 4.0.0) ## bookdown 0.19 2020-05-15 [1] CRAN (R 4.0.0) ## broom 0.5.6 2020-04-20 [1] CRAN (R 4.0.0) ## callr 3.4.3 2020-03-28 [1] CRAN (R 4.0.0) ## cellranger 1.1.0 2016-07-27 [1] CRAN (R 4.0.0) ## cli 2.0.2 2020-02-28 [1] CRAN (R 4.0.0) ## cluster * 2.1.0 2019-06-19 [2] CRAN (R 4.0.0) ## codetools 0.2-16 2018-12-24 [2] CRAN (R 4.0.0) ## colorspace 1.4-1 2019-03-18 [1] CRAN (R 4.0.0) ## cowplot 1.0.0 2019-07-11 [1] CRAN (R 4.0.0) ## crayon 1.3.4 2017-09-16 [1] CRAN (R 4.0.0) ## data.table 1.12.8 2019-12-09 [1] CRAN (R 4.0.0) ## DBI 1.1.0 2019-12-15 [1] CRAN (R 4.0.0) ## dbplyr 1.4.3 2020-04-19 [1] CRAN (R 4.0.0) ## DelayedArray * 0.14.0 2020-04-27 [1] Bioconductor ## DelayedMatrixStats 1.10.0 2020-04-27 [1] Bioconductor ## desc 1.2.0 2018-05-01 [1] CRAN (R 4.0.0) ## devtools 2.3.0 2020-04-10 [1] CRAN (R 4.0.0) ## digest 0.6.25 2020-02-23 [1] CRAN (R 4.0.0) ## doParallel 1.0.15 2019-08-02 [1] CRAN (R 4.0.0) ## dplyr * 0.8.5 2020-03-07 [1] CRAN (R 4.0.0) ## dqrng 0.2.1 2019-05-17 [1] CRAN (R 4.0.0) ## edgeR 3.30.0 2020-04-27 [1] Bioconductor ## ellipsis 0.3.0 2019-09-20 [1] CRAN (R 4.0.0) ## evaluate 0.14 2019-05-28 [1] CRAN (R 4.0.0) ## extrafont * 0.17 2014-12-08 [1] CRAN (R 4.0.0) ## extrafontdb 1.0 2012-06-11 [1] CRAN (R 4.0.0) ## fansi 0.4.1 2020-01-08 [1] CRAN (R 4.0.0) ## farver 2.0.3 2020-01-16 [1] CRAN (R 4.0.0) ## fitdistrplus 1.0-14 2019-01-23 [1] CRAN (R 4.0.0) ## FNN 1.1.3 2019-02-15 [1] CRAN (R 4.0.0) ## forcats * 0.5.0 2020-03-01 [1] CRAN (R 4.0.0) ## foreach 1.5.0 2020-03-30 [1] CRAN (R 4.0.0) ## fs 1.4.1 2020-04-04 [1] CRAN (R 4.0.0) ## future 1.17.0 2020-04-18 [1] CRAN (R 4.0.0) ## future.apply 1.5.0 2020-04-17 [1] CRAN (R 4.0.0) ## generics 0.0.2 2018-11-29 [1] CRAN (R 4.0.0) ## GenomeInfoDb * 1.24.0 2020-04-27 [1] Bioconductor ## GenomeInfoDbData 1.2.3 2020-05-11 [1] Bioconductor ## GenomicRanges * 1.40.0 2020-04-27 [1] Bioconductor ## ggbeeswarm 0.6.0 2017-08-07 [1] CRAN (R 4.0.0) ## ggplot2 * 3.3.0 2020-03-05 [1] CRAN (R 4.0.0) ## ggrepel 0.8.2 2020-03-08 [1] CRAN (R 4.0.0) ## ggridges 0.5.2 2020-01-12 [1] CRAN (R 4.0.0) ## globals 0.12.5 2019-12-07 [1] CRAN (R 4.0.0) ## glue 1.4.0 2020-04-03 [1] CRAN (R 4.0.0) ## gridBase 0.4-7 2014-02-24 [1] CRAN (R 4.0.0) ## gridExtra * 2.3 2017-09-09 [1] CRAN (R 4.0.0) ## gtable 0.3.0 2019-03-25 [1] CRAN (R 4.0.0) ## gtools 3.8.2 2020-03-31 [1] CRAN (R 4.0.0) ## haven 2.2.0 2019-11-08 [1] CRAN (R 4.0.0) ## highr 0.8 2019-03-20 [1] CRAN (R 4.0.0) ## hms 0.5.3 2020-01-08 [1] CRAN (R 4.0.0) ## htmltools 0.4.0 2019-10-04 [1] CRAN (R 4.0.0) ## htmlwidgets 1.5.1 2019-10-08 [1] CRAN (R 4.0.0) ## httr 1.4.1 2019-08-05 [1] CRAN (R 4.0.0) ## ica 1.0-2 2018-05-24 [1] CRAN (R 4.0.0) ## igraph 1.2.5 2020-03-19 [1] CRAN (R 4.0.0) ## IRanges * 2.22.1 2020-04-28 [1] Bioconductor ## irlba 2.3.3 2019-02-05 [1] CRAN (R 4.0.0) ## iterators 1.0.12 2019-07-26 [1] CRAN (R 4.0.0) ## jsonlite 1.6.1 2020-02-02 [1] CRAN (R 4.0.0) ## KernSmooth 2.23-16 2019-10-15 [2] CRAN (R 4.0.0) ## knitr 1.28 2020-02-06 [1] CRAN (R 4.0.0) ## labeling 0.3 2014-08-23 [1] CRAN (R 4.0.0) ## lattice 0.20-41 2020-04-02 [2] CRAN (R 4.0.0) ## lazyeval 0.2.2 2019-03-15 [1] CRAN (R 4.0.0) ## leiden 0.3.3 2020-02-04 [1] CRAN (R 4.0.0) ## lifecycle 0.2.0 2020-03-06 [1] CRAN (R 4.0.0) ## limma 3.44.1 2020-04-28 [1] Bioconductor ## listenv 0.8.0 2019-12-05 [1] CRAN (R 4.0.0) ## lmtest 0.9-37 2019-04-30 [1] CRAN (R 4.0.0) ## locfit 1.5-9.4 2020-03-25 [1] CRAN (R 4.0.0) ## lsei 1.2-0.1 2020-05-06 [1] CRAN (R 4.0.0) ## lubridate 1.7.8 2020-04-06 [1] CRAN (R 4.0.0) ## magrittr 1.5 2014-11-22 [1] CRAN (R 4.0.0) ## MASS 7.3-51.5 2019-12-20 [2] CRAN (R 4.0.0) ## Matrix 1.2-18 2019-11-27 [2] CRAN (R 4.0.0) ## matrixStats * 0.56.0 2020-03-13 [1] CRAN (R 4.0.0) ## mclust * 5.4.6 2020-04-11 [1] CRAN (R 4.0.0) ## memoise 1.1.0 2017-04-21 [1] CRAN (R 4.0.0) ## modelr 0.1.7 2020-04-30 [1] CRAN (R 4.0.0) ## munsell 0.5.0 2018-06-12 [1] CRAN (R 4.0.0) ## nlme 3.1-147 2020-04-13 [2] CRAN (R 4.0.0) ## NMF * 0.22.0 2020-02-12 [1] CRAN (R 4.0.0) ## npsurv 0.4-0.1 2020-05-06 [1] CRAN (R 4.0.0) ## org.Dr.eg.db * 3.11.1 2020-05-11 [1] Bioconductor ## patchwork 1.0.0 2019-12-01 [1] CRAN (R 4.0.0) ## pbapply 1.4-2 2019-08-31 [1] CRAN (R 4.0.0) ## pheatmap * 1.0.12 2019-01-04 [1] CRAN (R 4.0.0) ## pillar 1.4.4 2020-05-05 [1] CRAN (R 4.0.0) ## pkgbuild 1.0.8 2020-05-07 [1] CRAN (R 4.0.0) ## pkgconfig 2.0.3 2019-09-22 [1] CRAN (R 4.0.0) ## pkgload 1.0.2 2018-10-29 [1] CRAN (R 4.0.0) ## pkgmaker * 0.31.1 2020-03-19 [1] CRAN (R 4.0.0) ## plotly 4.9.2.1 2020-04-04 [1] CRAN (R 4.0.0) ## plyr 1.8.6 2020-03-03 [1] CRAN (R 4.0.0) ## png 0.1-7 2013-12-03 [1] CRAN (R 4.0.0) ## prettyunits 1.1.1 2020-01-24 [1] CRAN (R 4.0.0) ## processx 3.4.2 2020-02-09 [1] CRAN (R 4.0.0) ## ps 1.3.3 2020-05-08 [1] CRAN (R 4.0.0) ## purrr * 0.3.4 2020-04-17 [1] CRAN (R 4.0.0) ## R.methodsS3 * 1.8.0 2020-02-14 [1] CRAN (R 4.0.0) ## R.oo * 1.23.0 2019-11-03 [1] CRAN (R 4.0.0) ## R.utils * 2.9.2 2019-12-08 [1] CRAN (R 4.0.0) ## R6 2.4.1 2019-11-12 [1] CRAN (R 4.0.0) ## RANN 2.6.1 2019-01-08 [1] CRAN (R 4.0.0) ## rappdirs 0.3.1 2016-03-28 [1] CRAN (R 4.0.0) ## RColorBrewer * 1.1-2 2014-12-07 [1] CRAN (R 4.0.0) ## Rcpp 1.0.4.6 2020-04-09 [1] CRAN (R 4.0.0) ## RcppAnnoy 0.0.16 2020-03-08 [1] CRAN (R 4.0.0) ## RCurl 1.98-1.2 2020-04-18 [1] CRAN (R 4.0.0) ## readr * 1.3.1 2018-12-21 [1] CRAN (R 4.0.0) ## readxl 1.3.1 2019-03-13 [1] CRAN (R 4.0.0) ## registry * 0.5-1 2019-03-05 [1] CRAN (R 4.0.0) ## remotes 2.1.1 2020-02-15 [1] CRAN (R 4.0.0) ## reprex 0.3.0 2019-05-16 [1] CRAN (R 4.0.0) ## reshape2 1.4.4 2020-04-09 [1] CRAN (R 4.0.0) ## reticulate 1.15 2020-04-02 [1] CRAN (R 4.0.0) ## rlang 0.4.6 2020-05-02 [1] CRAN (R 4.0.0) ## rmarkdown 2.1 2020-01-20 [1] CRAN (R 4.0.0) ## rngtools * 1.5 2020-01-23 [1] CRAN (R 4.0.0) ## ROCR 1.0-11 2020-05-02 [1] CRAN (R 4.0.0) ## rprojroot 1.3-2 2018-01-03 [1] CRAN (R 4.0.0) ## RSpectra 0.16-0 2019-12-01 [1] CRAN (R 4.0.0) ## RSQLite 2.2.0 2020-01-07 [1] CRAN (R 4.0.0) ## rstudioapi 0.11 2020-02-07 [1] CRAN (R 4.0.0) ## rsvd 1.0.3 2020-02-17 [1] CRAN (R 4.0.0) ## Rtsne 0.15 2018-11-10 [1] CRAN (R 4.0.0) ## Rttf2pt1 1.3.8 2020-01-10 [1] CRAN (R 4.0.0) ## rvest 0.3.5 2019-11-08 [1] CRAN (R 4.0.0) ## S4Vectors * 0.26.0 2020-04-27 [1] Bioconductor ## scales * 1.1.1 2020-05-11 [1] CRAN (R 4.0.0) ## scater * 1.16.0 2020-04-27 [1] Bioconductor ## scran * 1.16.0 2020-04-27 [1] Bioconductor ## sctransform 0.2.1 2019-12-17 [1] CRAN (R 4.0.0) ## sessioninfo 1.1.1 2018-11-05 [1] CRAN (R 4.0.0) ## Seurat * 3.1.5 2020-04-16 [1] CRAN (R 4.0.0) ## SingleCellExperiment * 1.10.1 2020-04-28 [1] Bioconductor ## statmod 1.4.34 2020-02-17 [1] CRAN (R 4.0.0) ## stringi 1.4.6 2020-02-17 [1] CRAN (R 4.0.0) ## stringr * 1.4.0 2019-02-10 [1] CRAN (R 4.0.0) ## SummarizedExperiment * 1.18.1 2020-04-30 [1] Bioconductor ## survival 3.1-12 2020-04-10 [2] CRAN (R 4.0.0) ## testthat 2.3.2 2020-03-02 [1] CRAN (R 4.0.0) ## tibble * 3.0.1 2020-04-20 [1] CRAN (R 4.0.0) ## tidyr * 1.0.3 2020-05-07 [1] CRAN (R 4.0.0) ## tidyselect 1.0.0 2020-01-27 [1] CRAN (R 4.0.0) ## tidyverse * 1.3.0 2019-11-21 [1] CRAN (R 4.0.0) ## tsne 0.1-3 2016-07-15 [1] CRAN (R 4.0.0) ## usethis 1.6.1 2020-04-29 [1] CRAN (R 4.0.0) ## utf8 1.1.4 2018-05-24 [1] CRAN (R 4.0.0) ## uwot 0.1.8 2020-03-16 [1] CRAN (R 4.0.0) ## vctrs 0.2.4 2020-03-10 [1] CRAN (R 4.0.0) ## vipor 0.4.5 2017-03-22 [1] CRAN (R 4.0.0) ## viridis * 0.5.1 2018-03-29 [1] CRAN (R 4.0.0) ## viridisLite * 0.3.0 2018-02-01 [1] CRAN (R 4.0.0) ## withr 2.2.0 2020-04-20 [1] CRAN (R 4.0.0) ## xfun 0.13 2020-04-13 [1] CRAN (R 4.0.0) ## xml2 1.3.2 2020-04-23 [1] CRAN (R 4.0.0) ## xtable 1.8-4 2019-04-21 [1] CRAN (R 4.0.0) ## XVector 0.28.0 2020-04-27 [1] Bioconductor ## yaml 2.2.1 2020-02-01 [1] CRAN (R 4.0.0) ## zlibbioc 1.34.0 2020-04-27 [1] Bioconductor ## zoo 1.8-8 2020-05-02 [1] CRAN (R 4.0.0) ## ## [1] D:/R_packages ## [2] C:/Program Files/R/R-4.0.0/library 9.14 Solutions Use the ggsave function. ggsave(“2g)nm_dotplot.tiff”, nm_dotplot, dpi = 400, width = 12, height = 8,units = c(“cm”)) ggsave(“2g)meso_dotplot.tiff”, meso_dotplot, dpi = 400, width = 12, height = 8,units = c(“cm”)) ggsave(“2g)neural_dotplot.tiff”, neural_dotplot, dpi = 400, width = 12, height = 8,units = c(“cm”)) lapply returns a list of the same length as the input vector. sapply (simple apply) returns a vector. "],
["pseudotime.html", "Chapter 10 Pseudotime 10.1 Importing libraries 10.2 Importing data 10.3 TradeSeq workflow analyses 10.4 Session Info 10.5 Solutions", " Chapter 10 Pseudotime Our aim is to explore how the expression of marker genes change along the neural and mesodermal trajectories, with the neuromesodermal progenitors acting as the root of the bifurcation. We will perform pseudotime inference with the slingshot package to assign each cell a measure of biological progress along each trajectory. More precisely, for two cells A and B ordered along a trajectory, if cell B has a larger pseudotime value than cell A, then cell B is interpreted as exhibiting a gene expression profile of a more differentiated cell relative to cell A. Subsequently, we use the tradeseq package to analyse the change in gene expression along the neural and mesodermal lineage trajectories. 10.1 Importing libraries library(SingleCellExperiment) library(slingshot) library(RColorBrewer) library(tidyverse) library(Seurat) library(tradeSeq) library(clusterExperiment) library(cowplot) 10.2 Importing data TBcells &lt;- readRDS(&quot;rds/TBcells_subclustered.rds&quot;) #Convert to SCE object TB_sce &lt;- as.SingleCellExperiment(x = TBcells, assay = &quot;SCT&quot;) table(colData(TB_sce)$subclusters_names) ## ## Maturation zone Nascent somites NMps ## 62 76 47 ## Posterior NT Posterior PSM Pou5f3+ Posterior NT ## 103 140 73 ## Tail somites ## 50 Q1 How would you subset the data to contain only cells in the NMp, maturation zone, posterior PSM and pou5f3+ posterior NT clusters? To run slingshot on our dataset, we need to provide it with the coordinates of the reduced dimension and the cluster labels. For comparison with our previous work, we will use the UMAP coordinates and the subcluster_names labels, which are both stored in the converted SingleCellExperiment object. The slingshot wrapper function performs 2 necessary steps in this method of lineage inference. First, it constructs a cluster-based minimum spanning tree (MST) on the cells to obtain a global lineage structure using the getLineages function. This is followed by the fitting of principle curves for each lineage called with the getCurves function. sce_sling &lt;- slingshot(TB_sce, clusterLabels = &quot;subclusters_names&quot;, reducedDim = &quot;UMAP&quot;, start.clus = &quot;NMps&quot; ) ## Using full covariance matrix clusters &lt;- ifelse(colData(TB_sce)$subclusters_names == &quot;NMps&quot;, 1, ifelse(colData(TB_sce)$subclusters_names == &quot;Maturation zone&quot;,2, ifelse(colData(TB_sce)$subclusters_names == &quot;Posterior PSM&quot;, 3, ifelse(colData(TB_sce)$subclusters_names == &quot;Pou5f3+ Posterior NT&quot;, 4,ifelse(colData(TB_sce)$subclusters_names == &quot;Posterior NT&quot;, 5,ifelse(colData(TB_sce)$subclusters_names == &quot;Nascent somites&quot;, 6,ifelse(colData(TB_sce)$subclusters_names == &quot;Tail somites&quot;, 7, NA))))))) clust_col = data.frame(names = colData(TB_sce)$subclusters_names, clusters = clusters, colors = brewer.pal(9,&quot;Set1&quot;)[clusters]) %&gt;% arrange(clusters) %&gt;% distinct() plot(reducedDims(sce_sling)$UMAP, col = brewer.pal(9,&quot;Set1&quot;)[clusters], pch=16, asp = 1) lines(SlingshotDataSet(sce_sling), lwd=1, type = &quot;lineages&quot;, col=&#39;black&#39;) legend(-11, -0.7, legend=c(&quot;NMps&quot;, &quot;Maturation Zone&quot;, &quot;Posterior PSM&quot;, &quot;Pou5f3+ posterior NT&quot;, &quot;Posterior NT&quot;, &quot;Nascent Somites&quot;, &quot;Tail Somites&quot;), col=clust_col$colors, pch = 16, pt.cex = 0.8, cex = 0.8, bty=&#39;n&#39;, box.lty=0) TBcells &lt;- FindVariableFeatures(TBcells) sce_sling &lt;- sce_sling[VariableFeatures(TBcells),] counts &lt;- assays(sce_sling)$counts %&gt;% as.matrix logcounts &lt;- assays(sce_sling)$logcounts %&gt;% as.matrix() 10.3 TradeSeq workflow analyses Tradeseq vignette set.seed(5) icMat &lt;- evaluateK(counts = counts, sds = SlingshotDataSet(sce_sling), k = 3:10, nGenes = 200, verbose = T) dim(counts) ## [1] 2000 551 dim((sce_sling)) ## [1] 2000 551 sce &lt;- fitGAM(counts = counts, sds = SlingshotDataSet(sce_sling), nknots = 10) saveRDS(sce, file = &quot;rds/6_slingshot.rds&quot;) sce &lt;- readRDS(&quot;rds/6_slingshot.rds&quot;) assoRes &lt;- associationTest(sce) %&gt;% tibble::rownames_to_column() %&gt;% dplyr::filter(pvalue &lt; 1e-10) asso_genes &lt;- assoRes$rowname # Clustering expression patterns nPointsClus &lt;- 20 #clusterExperiment::listBuiltInFunctions() clustPat &lt;- clusterExpressionPatterns(sce, nPoints = nPointsClus, genes = asso_genes) ## 36 parameter combinations, 36 use sequential method, 36 use subsampling method ## Running Clustering on Parameter Combinations... ## done. saveRDS(clustPat, file = &quot;rds/6_clusterExperiment.rds&quot;) clustPat &lt;- readRDS(file = &quot;rds/6_clusterExperiment.rds&quot;) clusterLabels &lt;- primaryCluster(clustPat$rsec) #clustPat genesWithinClust &lt;- rownames(clustPat$yhatScaled[clusterLabels == 2, ]) (genesWithinClust)[5] ## [1] &quot;tbx6&quot; cUniq &lt;- unique(clusterLabels) cUniq &lt;- cUniq[!cUniq == -1] # remove unclustered genes cUniq &lt;- sort(cUniq) plots &lt;- list() for (xx in cUniq[1:10]) { cId &lt;- which(clusterLabels == xx) p &lt;- ggplot(data = data.frame(x = 1:nPointsClus, y = rep(range(clustPat$yhatScaled[cId, ]), nPointsClus / 2)), aes(x = x, y = y)) + geom_point(alpha = 0) + labs(title = paste0(&quot;Cluster &quot;, xx), x = &quot;Pseudotime&quot;, y = &quot;Normalized expression&quot;) + theme_classic() for (ii in 1:length(cId)) { geneId &lt;- rownames(clustPat$yhatScaled)[cId[ii]] p &lt;- p + geom_line(data = data.frame(x = rep(1:nPointsClus, 2), y = clustPat$yhatScaled[geneId, ], lineage = rep(0:1, each = nPointsClus)), aes(col = as.character(lineage), group = lineage), lwd = 1.5) } p &lt;- p + guides(color = FALSE) + scale_color_manual(values = c(&quot;orange&quot;, &quot;darkseagreen3&quot;), breaks = c(&quot;0&quot;, &quot;1&quot;)) plots[[as.character(xx)]] &lt;- p } plots$ncol &lt;- 3 do.call(cowplot::plot_grid, plots) 10.4 Session Info View Session Info devtools::session_info() ## - Session info --------------------------------------------------------------- ## setting value ## version R version 4.0.0 (2020-04-24) ## os Windows 10 x64 ## system x86_64, mingw32 ## ui RTerm ## language (EN) ## collate English_United Kingdom.1252 ## ctype English_United Kingdom.1252 ## tz Asia/Kuala_Lumpur ## date 2020-06-04 ## ## - Packages ------------------------------------------------------------------- ## package * version date lib source ## ade4 1.7-15 2020-02-13 [1] CRAN (R 4.0.0) ## annotate 1.66.0 2020-04-27 [1] Bioconductor ## AnnotationDbi * 1.50.0 2020-04-27 [1] Bioconductor ## ape 5.3 2019-03-17 [1] CRAN (R 4.0.0) ## assertthat 0.2.1 2019-03-21 [1] CRAN (R 4.0.0) ## backports 1.1.6 2020-04-05 [1] CRAN (R 4.0.0) ## beeswarm 0.2.3 2016-04-25 [1] CRAN (R 4.0.0) ## bibtex 0.4.2.2 2020-01-02 [1] CRAN (R 4.0.0) ## Biobase * 2.48.0 2020-04-27 [1] Bioconductor ## BiocGenerics * 0.34.0 2020-04-27 [1] Bioconductor ## BiocNeighbors 1.6.0 2020-04-27 [1] Bioconductor ## BiocParallel 1.22.0 2020-04-27 [1] Bioconductor ## BiocSingular 1.4.0 2020-04-27 [1] Bioconductor ## bit 1.1-15.2 2020-02-10 [1] CRAN (R 4.0.0) ## bit64 0.9-7 2017-05-08 [1] CRAN (R 4.0.0) ## bitops 1.0-6 2013-08-17 [1] CRAN (R 4.0.0) ## blob 1.2.1 2020-01-20 [1] CRAN (R 4.0.0) ## bookdown 0.19 2020-05-15 [1] CRAN (R 4.0.0) ## broom 0.5.6 2020-04-20 [1] CRAN (R 4.0.0) ## callr 3.4.3 2020-03-28 [1] CRAN (R 4.0.0) ## cellranger 1.1.0 2016-07-27 [1] CRAN (R 4.0.0) ## cli 2.0.2 2020-02-28 [1] CRAN (R 4.0.0) ## cluster * 2.1.0 2019-06-19 [2] CRAN (R 4.0.0) ## clusterExperiment * 2.8.0 2020-04-27 [1] Bioconductor ## codetools 0.2-16 2018-12-24 [2] CRAN (R 4.0.0) ## colorspace 1.4-1 2019-03-18 [1] CRAN (R 4.0.0) ## combinat 0.0-8 2012-10-29 [1] CRAN (R 4.0.0) ## cowplot * 1.0.0 2019-07-11 [1] CRAN (R 4.0.0) ## crayon 1.3.4 2017-09-16 [1] CRAN (R 4.0.0) ## data.table 1.12.8 2019-12-09 [1] CRAN (R 4.0.0) ## DBI 1.1.0 2019-12-15 [1] CRAN (R 4.0.0) ## dbplyr 1.4.3 2020-04-19 [1] CRAN (R 4.0.0) ## DDRTree 0.1.5 2017-04-30 [1] CRAN (R 4.0.0) ## DelayedArray * 0.14.0 2020-04-27 [1] Bioconductor ## DelayedMatrixStats 1.10.0 2020-04-27 [1] Bioconductor ## densityClust 0.3 2017-10-24 [1] CRAN (R 4.0.0) ## desc 1.2.0 2018-05-01 [1] CRAN (R 4.0.0) ## devtools 2.3.0 2020-04-10 [1] CRAN (R 4.0.0) ## digest 0.6.25 2020-02-23 [1] CRAN (R 4.0.0) ## docopt 0.6.1 2018-10-11 [1] CRAN (R 4.0.0) ## doParallel 1.0.15 2019-08-02 [1] CRAN (R 4.0.0) ## dplyr * 0.8.5 2020-03-07 [1] CRAN (R 4.0.0) ## dqrng 0.2.1 2019-05-17 [1] CRAN (R 4.0.0) ## edgeR 3.30.0 2020-04-27 [1] Bioconductor ## ellipsis 0.3.0 2019-09-20 [1] CRAN (R 4.0.0) ## evaluate 0.14 2019-05-28 [1] CRAN (R 4.0.0) ## extrafont * 0.17 2014-12-08 [1] CRAN (R 4.0.0) ## extrafontdb 1.0 2012-06-11 [1] CRAN (R 4.0.0) ## fansi 0.4.1 2020-01-08 [1] CRAN (R 4.0.0) ## farver 2.0.3 2020-01-16 [1] CRAN (R 4.0.0) ## fastICA 1.2-2 2019-07-08 [1] CRAN (R 4.0.0) ## fitdistrplus 1.0-14 2019-01-23 [1] CRAN (R 4.0.0) ## FNN 1.1.3 2019-02-15 [1] CRAN (R 4.0.0) ## forcats * 0.5.0 2020-03-01 [1] CRAN (R 4.0.0) ## foreach 1.5.0 2020-03-30 [1] CRAN (R 4.0.0) ## fs 1.4.1 2020-04-04 [1] CRAN (R 4.0.0) ## future 1.17.0 2020-04-18 [1] CRAN (R 4.0.0) ## future.apply 1.5.0 2020-04-17 [1] CRAN (R 4.0.0) ## genefilter 1.70.0 2020-04-27 [1] Bioconductor ## generics 0.0.2 2018-11-29 [1] CRAN (R 4.0.0) ## GenomeInfoDb * 1.24.0 2020-04-27 [1] Bioconductor ## GenomeInfoDbData 1.2.3 2020-05-11 [1] Bioconductor ## GenomicRanges * 1.40.0 2020-04-27 [1] Bioconductor ## ggbeeswarm 0.6.0 2017-08-07 [1] CRAN (R 4.0.0) ## ggplot2 * 3.3.0 2020-03-05 [1] CRAN (R 4.0.0) ## ggrepel 0.8.2 2020-03-08 [1] CRAN (R 4.0.0) ## ggridges 0.5.2 2020-01-12 [1] CRAN (R 4.0.0) ## globals 0.12.5 2019-12-07 [1] CRAN (R 4.0.0) ## glue 1.4.0 2020-04-03 [1] CRAN (R 4.0.0) ## gridBase 0.4-7 2014-02-24 [1] CRAN (R 4.0.0) ## gridExtra * 2.3 2017-09-09 [1] CRAN (R 4.0.0) ## gtable 0.3.0 2019-03-25 [1] CRAN (R 4.0.0) ## gtools 3.8.2 2020-03-31 [1] CRAN (R 4.0.0) ## haven 2.2.0 2019-11-08 [1] CRAN (R 4.0.0) ## HDF5Array 1.16.0 2020-04-27 [1] Bioconductor ## highr 0.8 2019-03-20 [1] CRAN (R 4.0.0) ## hms 0.5.3 2020-01-08 [1] CRAN (R 4.0.0) ## howmany 0.3-1 2012-06-01 [1] CRAN (R 4.0.0) ## HSMMSingleCell 1.8.0 2020-05-07 [1] Bioconductor ## htmltools 0.4.0 2019-10-04 [1] CRAN (R 4.0.0) ## htmlwidgets 1.5.1 2019-10-08 [1] CRAN (R 4.0.0) ## httr 1.4.1 2019-08-05 [1] CRAN (R 4.0.0) ## ica 1.0-2 2018-05-24 [1] CRAN (R 4.0.0) ## igraph 1.2.5 2020-03-19 [1] CRAN (R 4.0.0) ## IRanges * 2.22.1 2020-04-28 [1] Bioconductor ## irlba 2.3.3 2019-02-05 [1] CRAN (R 4.0.0) ## iterators 1.0.12 2019-07-26 [1] CRAN (R 4.0.0) ## jsonlite 1.6.1 2020-02-02 [1] CRAN (R 4.0.0) ## kernlab 0.9-29 2019-11-12 [1] CRAN (R 4.0.0) ## KernSmooth 2.23-16 2019-10-15 [2] CRAN (R 4.0.0) ## knitr 1.28 2020-02-06 [1] CRAN (R 4.0.0) ## labeling 0.3 2014-08-23 [1] CRAN (R 4.0.0) ## lattice 0.20-41 2020-04-02 [2] CRAN (R 4.0.0) ## lazyeval 0.2.2 2019-03-15 [1] CRAN (R 4.0.0) ## leiden 0.3.3 2020-02-04 [1] CRAN (R 4.0.0) ## lifecycle 0.2.0 2020-03-06 [1] CRAN (R 4.0.0) ## limma 3.44.1 2020-04-28 [1] Bioconductor ## listenv 0.8.0 2019-12-05 [1] CRAN (R 4.0.0) ## lmtest 0.9-37 2019-04-30 [1] CRAN (R 4.0.0) ## locfdr 1.1-8 2015-07-15 [1] CRAN (R 4.0.0) ## locfit 1.5-9.4 2020-03-25 [1] CRAN (R 4.0.0) ## lsei 1.2-0.1 2020-05-06 [1] CRAN (R 4.0.0) ## lubridate 1.7.8 2020-04-06 [1] CRAN (R 4.0.0) ## magrittr 1.5 2014-11-22 [1] CRAN (R 4.0.0) ## MASS 7.3-51.5 2019-12-20 [2] CRAN (R 4.0.0) ## Matrix 1.2-18 2019-11-27 [2] CRAN (R 4.0.0) ## matrixStats * 0.56.0 2020-03-13 [1] CRAN (R 4.0.0) ## mclust * 5.4.6 2020-04-11 [1] CRAN (R 4.0.0) ## memoise 1.1.0 2017-04-21 [1] CRAN (R 4.0.0) ## mgcv 1.8-31 2019-11-09 [2] CRAN (R 4.0.0) ## modelr 0.1.7 2020-04-30 [1] CRAN (R 4.0.0) ## monocle 2.16.0 2020-04-27 [1] Bioconductor ## munsell 0.5.0 2018-06-12 [1] CRAN (R 4.0.0) ## nlme 3.1-147 2020-04-13 [2] CRAN (R 4.0.0) ## NMF * 0.22.0 2020-02-12 [1] CRAN (R 4.0.0) ## npsurv 0.4-0.1 2020-05-06 [1] CRAN (R 4.0.0) ## org.Dr.eg.db * 3.11.1 2020-05-11 [1] Bioconductor ## patchwork 1.0.0 2019-12-01 [1] CRAN (R 4.0.0) ## pbapply 1.4-2 2019-08-31 [1] CRAN (R 4.0.0) ## pheatmap * 1.0.12 2019-01-04 [1] CRAN (R 4.0.0) ## phylobase 0.8.10 2020-03-01 [1] CRAN (R 4.0.0) ## pillar 1.4.4 2020-05-05 [1] CRAN (R 4.0.0) ## pkgbuild 1.0.8 2020-05-07 [1] CRAN (R 4.0.0) ## pkgconfig 2.0.3 2019-09-22 [1] CRAN (R 4.0.0) ## pkgload 1.0.2 2018-10-29 [1] CRAN (R 4.0.0) ## pkgmaker * 0.31.1 2020-03-19 [1] CRAN (R 4.0.0) ## plotly 4.9.2.1 2020-04-04 [1] CRAN (R 4.0.0) ## plyr 1.8.6 2020-03-03 [1] CRAN (R 4.0.0) ## png 0.1-7 2013-12-03 [1] CRAN (R 4.0.0) ## prettyunits 1.1.1 2020-01-24 [1] CRAN (R 4.0.0) ## princurve * 2.1.4 2019-05-29 [1] CRAN (R 4.0.0) ## processx 3.4.2 2020-02-09 [1] CRAN (R 4.0.0) ## progress 1.2.2 2019-05-16 [1] CRAN (R 4.0.0) ## ps 1.3.3 2020-05-08 [1] CRAN (R 4.0.0) ## purrr * 0.3.4 2020-04-17 [1] CRAN (R 4.0.0) ## qlcMatrix 0.9.7 2018-04-20 [1] CRAN (R 4.0.0) ## R.methodsS3 * 1.8.0 2020-02-14 [1] CRAN (R 4.0.0) ## R.oo * 1.23.0 2019-11-03 [1] CRAN (R 4.0.0) ## R.utils * 2.9.2 2019-12-08 [1] CRAN (R 4.0.0) ## R6 2.4.1 2019-11-12 [1] CRAN (R 4.0.0) ## RANN 2.6.1 2019-01-08 [1] CRAN (R 4.0.0) ## rappdirs 0.3.1 2016-03-28 [1] CRAN (R 4.0.0) ## RColorBrewer * 1.1-2 2014-12-07 [1] CRAN (R 4.0.0) ## Rcpp 1.0.4.6 2020-04-09 [1] CRAN (R 4.0.0) ## RcppAnnoy 0.0.16 2020-03-08 [1] CRAN (R 4.0.0) ## RCurl 1.98-1.2 2020-04-18 [1] CRAN (R 4.0.0) ## readr * 1.3.1 2018-12-21 [1] CRAN (R 4.0.0) ## readxl 1.3.1 2019-03-13 [1] CRAN (R 4.0.0) ## registry * 0.5-1 2019-03-05 [1] CRAN (R 4.0.0) ## remotes 2.1.1 2020-02-15 [1] CRAN (R 4.0.0) ## reprex 0.3.0 2019-05-16 [1] CRAN (R 4.0.0) ## reshape2 1.4.4 2020-04-09 [1] CRAN (R 4.0.0) ## reticulate 1.15 2020-04-02 [1] CRAN (R 4.0.0) ## rhdf5 2.32.0 2020-04-27 [1] Bioconductor ## Rhdf5lib 1.10.0 2020-04-27 [1] Bioconductor ## rlang 0.4.6 2020-05-02 [1] CRAN (R 4.0.0) ## rmarkdown 2.1 2020-01-20 [1] CRAN (R 4.0.0) ## rncl 0.8.4 2020-02-10 [1] CRAN (R 4.0.0) ## RNeXML 2.4.4 2020-05-10 [1] CRAN (R 4.0.0) ## rngtools * 1.5 2020-01-23 [1] CRAN (R 4.0.0) ## ROCR 1.0-11 2020-05-02 [1] CRAN (R 4.0.0) ## rprojroot 1.3-2 2018-01-03 [1] CRAN (R 4.0.0) ## RSpectra 0.16-0 2019-12-01 [1] CRAN (R 4.0.0) ## RSQLite 2.2.0 2020-01-07 [1] CRAN (R 4.0.0) ## rstudioapi 0.11 2020-02-07 [1] CRAN (R 4.0.0) ## rsvd 1.0.3 2020-02-17 [1] CRAN (R 4.0.0) ## Rtsne 0.15 2018-11-10 [1] CRAN (R 4.0.0) ## Rttf2pt1 1.3.8 2020-01-10 [1] CRAN (R 4.0.0) ## rvest 0.3.5 2019-11-08 [1] CRAN (R 4.0.0) ## S4Vectors * 0.26.0 2020-04-27 [1] Bioconductor ## scales * 1.1.1 2020-05-11 [1] CRAN (R 4.0.0) ## scater * 1.16.0 2020-04-27 [1] Bioconductor ## scran * 1.16.0 2020-04-27 [1] Bioconductor ## sctransform 0.2.1 2019-12-17 [1] CRAN (R 4.0.0) ## sessioninfo 1.1.1 2018-11-05 [1] CRAN (R 4.0.0) ## Seurat * 3.1.5 2020-04-16 [1] CRAN (R 4.0.0) ## SingleCellExperiment * 1.10.1 2020-04-28 [1] Bioconductor ## slam 0.1-47 2019-12-21 [1] CRAN (R 4.0.0) ## slingshot * 1.6.0 2020-04-27 [1] Bioconductor ## softImpute 1.4 2015-04-08 [1] CRAN (R 4.0.0) ## sparsesvd 0.2 2019-07-15 [1] CRAN (R 4.0.0) ## statmod 1.4.34 2020-02-17 [1] CRAN (R 4.0.0) ## stringi 1.4.6 2020-02-17 [1] CRAN (R 4.0.0) ## stringr * 1.4.0 2019-02-10 [1] CRAN (R 4.0.0) ## SummarizedExperiment * 1.18.1 2020-04-30 [1] Bioconductor ## survival 3.1-12 2020-04-10 [2] CRAN (R 4.0.0) ## testthat 2.3.2 2020-03-02 [1] CRAN (R 4.0.0) ## tibble * 3.0.1 2020-04-20 [1] CRAN (R 4.0.0) ## tidyr * 1.0.3 2020-05-07 [1] CRAN (R 4.0.0) ## tidyselect 1.0.0 2020-01-27 [1] CRAN (R 4.0.0) ## tidyverse * 1.3.0 2019-11-21 [1] CRAN (R 4.0.0) ## tradeSeq * 1.2.0 2020-04-27 [1] Bioconductor ## tsne 0.1-3 2016-07-15 [1] CRAN (R 4.0.0) ## usethis 1.6.1 2020-04-29 [1] CRAN (R 4.0.0) ## utf8 1.1.4 2018-05-24 [1] CRAN (R 4.0.0) ## uuid 0.1-4 2020-02-26 [1] CRAN (R 4.0.0) ## uwot 0.1.8 2020-03-16 [1] CRAN (R 4.0.0) ## vctrs 0.2.4 2020-03-10 [1] CRAN (R 4.0.0) ## VGAM 1.1-3 2020-04-28 [1] CRAN (R 4.0.0) ## vipor 0.4.5 2017-03-22 [1] CRAN (R 4.0.0) ## viridis * 0.5.1 2018-03-29 [1] CRAN (R 4.0.0) ## viridisLite * 0.3.0 2018-02-01 [1] CRAN (R 4.0.0) ## withr 2.2.0 2020-04-20 [1] CRAN (R 4.0.0) ## xfun 0.13 2020-04-13 [1] CRAN (R 4.0.0) ## XML 3.99-0.3 2020-01-20 [1] CRAN (R 4.0.0) ## xml2 1.3.2 2020-04-23 [1] CRAN (R 4.0.0) ## xtable 1.8-4 2019-04-21 [1] CRAN (R 4.0.0) ## XVector 0.28.0 2020-04-27 [1] Bioconductor ## yaml 2.2.1 2020-02-01 [1] CRAN (R 4.0.0) ## zinbwave 1.10.0 2020-04-27 [1] Bioconductor ## zlibbioc 1.34.0 2020-04-27 [1] Bioconductor ## zoo 1.8-8 2020-05-02 [1] CRAN (R 4.0.0) ## ## [1] D:/R_packages ## [2] C:/Program Files/R/R-4.0.0/library 10.5 Solutions TB_sce &lt;- TB_sce[, colData(TB_sce)\\(subclusters_names == &quot;NMps&quot; | colData(TB_sce)\\)subclusters_names == “Maturation zone”| colData(TB_sce)\\(subclusters_names == &quot;Posterior PSM&quot; | colData(TB_sce)\\)subclusters_names == “Pou5f3+ Posterior NT”] "],
["random-seeds.html", "Chapter 11 Random seeds 11.1 What is a random seed? 11.2 Simulations 11.3 Box-Muller transform", " Chapter 11 Random seeds 11.1 What is a random seed? Computers tend not to use truly random numbers. Instead they use algorithms called pseudorandom number generators (PRNGs) to produce ‘pseudorandom’ numbers. PRNGs are deterministic algorithms which produce sequences of numbers which have many of the same statistical properties as truly random sequences. They tend to work iteratively, the algorithm has a ‘hidden state’ which acts as an input to a complex transformation to produce an output, each time this occurs the hidden state is updated so that at the next step the algorithm will produce a different output. Because they are deterministic if the algorithm is in same state and receives the same input it will produce the same output. This can be a very useful property as often we would like to write some code which uses random numbers but we want to produce the same output every time we run it. The seed of a PRNG is a way of determining the starting value of the hidden state. Ordinarily these algorithms will take their seed from a source which is constantly changing, such as the computers clock time, which ensures that each time you produce random numbers they will be different. However we have the option to manually provide a seed to set the initial state. In R this is done with set.seed(n). 11.2 Simulations If we simulate and visualise two sets of gaussian data we can see that they are different as we might naturally expect. # Simulate set.seed(1) x1 &lt;- rnorm(10) x2 &lt;- rnorm(10) # Plot par(mfrow=c(1,2)) hist(x1) hist(x2) This is because after producing the first set of data our PRNG is no longer in the state specified by set.seed(1) and so the second call to rnorm() will be receive new random numbers and therefore it will be different. If however, we reseed the algorithm after producing the first dataset we will produce exactly the same set of pseudorandom numbers: # Set random seed to 1. set.seed(1) x1 &lt;- rnorm(10) # Reset the random seed to 1. set.seed(1) x2 &lt;- rnorm(10) # Plot par(mfrow=c(1,2)) hist(x1) hist(x2) Note the changes in the state of the PRNG only occur when it is used to produce our pseudorandom numbers. Therefore producing 10 gaussian samples with rnorm(10) is equivalent to sequentially producing two sets of 5 samples with rnorm(5) and combining them: # Sample all 10 in one command. set.seed(1) x1 &lt;- rnorm(10) # Sample two sets of 5 sequentially. set.seed(1) y1 &lt;- rnorm(5) y2 &lt;- rnorm(5) x2 &lt;- c(y1,y2) # Plot par(mfrow=c(1,2)) hist(x1) hist(x2) It doesn’t matter what code was used to produce the random numbers, what is important is the state of the PRNG ‘under the hood’. This can lead to some slightly unexpected behaviour which we will briefly look at below. First lets simulate a sequence of numbers from a uniform distribution between 0 and 1, \\(U(0,1)\\): set.seed(1) runif(5) ## [1] 0.2655087 0.3721239 0.5728534 0.9082078 0.2016819 When we precede this operation by simulating a single uniformly distributed number it will shift our sequence one forward, the second element moving to the first, the third to the second and so on, with a new number taking the 5th position: set.seed(1) seq1 &lt;- runif(5) set.seed(1) ignore &lt;- runif(1) seq2 &lt;- runif(5) df &lt;- data.frame(Seq1=c(seq1,NA),Seq2=c(NA,seq2)) knitr::kable(df,digits=3,row.names=TRUE) Seq1 Seq2 1 0.266 NA 2 0.372 0.372 3 0.573 0.573 4 0.908 0.908 5 0.202 0.202 6 NA 0.898 If we peek at the number we discarded we will see that, as we might have expected, it corresponds to the first element of our original sequence: ignore ## [1] 0.2655087 So far so good. However what will happen if, instead of a uniformly distribution variable, we simulate from a gaussian? set.seed(1) seq1 &lt;- runif(5) set.seed(1) ignore &lt;- rnorm(1) seq2 &lt;- runif(5) df &lt;- data.frame(Seq1=c(seq1,rep(NA,2)), Seq2=c(rep(NA,2),seq2)) knitr::kable(df,digits=3,row.names=TRUE) Seq1 Seq2 1 0.266 NA 2 0.372 NA 3 0.573 0.573 4 0.908 0.908 5 0.202 0.202 6 NA 0.898 7 NA 0.945 This time our samples have been shifted two positions forward! What is going on? The answer is a little out of the scope of this tutorial and is highly dependent on what algorithms are being used ‘under the hood’. The key lesson from this is that in practice it is very hard to keep track of the internal state of the PRNG. This is important as an analyses might only be reproducible if the PRNG is in exactly the same state when random number are used. Say you have two similar analysis scripts and you want some key algorithms inside to use the same pseudorandom numbers (for example you might want your tSNE plots to be reproducible). It is not sufficient to set the same random seed at the top of the script as it is all too easy to inadvertantly create a divergence in the hidden state of the PRNG in the two scripts. Therefore it is best to reseed the random number generator just before the relevant code and to ensure that any intervening operations are identical. 11.3 Box-Muller transform Box-Muller transform converts takes \\(U_1, U_2 \\sim U(0,1)\\) and converts them to a point in polar coordinates \\(R^2 = -2 \\ln U_1\\), \\(\\Theta = 2\\pi U_2.\\) taking the \\(X\\) and \\(Y\\) coordinates of this point gives two independent normally distributed variables. Thus it produces normal random numbers in pairs, producing a single random variable progresses the state of the PRNG the same amount as producing two: RNGkind(normal.kind=&quot;Box-Muller&quot;) set.seed(1) seq1 &lt;- runif(5) set.seed(1) ignore &lt;- rnorm(1) seq2 &lt;- runif(5) set.seed(1) ignore &lt;- rnorm(2) seq3 &lt;- runif(5) seq1 ## [1] 0.2655087 0.3721239 0.5728534 0.9082078 0.2016819 seq2 ## [1] 0.5728534 0.9082078 0.2016819 0.8983897 0.9446753 seq3 ## [1] 0.5728534 0.9082078 0.2016819 0.8983897 0.9446753 RNGkind(normal.kind=&quot;default&quot;) set.seed(1) seq1 &lt;- runif(5) set.seed(1) ignore &lt;- rnorm(1) seq2 &lt;- runif(5) set.seed(1) ignore &lt;- rnorm(2) seq3 &lt;- runif(5) seq1 ## [1] 0.2655087 0.3721239 0.5728534 0.9082078 0.2016819 seq2 ## [1] 0.5728534 0.9082078 0.2016819 0.8983897 0.9446753 seq3 ## [1] 0.2016819 0.8983897 0.9446753 0.6607978 0.6291140 "]
]
